<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link href="common/css/sf.css" rel="stylesheet" type="text/css" />
<title>IndPrinciples: 归纳法则</title>
<link href="common/jquery-ui/jquery-ui.css" rel="stylesheet">
<script src="common/jquery-ui/external/jquery/jquery.js"></script>
<script src="common/jquery-ui/jquery-ui.js"></script>
<script src="common/toggleproofs.js"></script>
<link href="common/css/lf.css" rel="stylesheet" type="text/css"/>
</head>

<body>

<div id="page">

<div id="header">
<div id='logoinheader'><a href='https://coq-zh.github.io/SF-zh/'>
<img src='common/media/image/sf_logo_sm.png' alt='Software Foundations Logo'></a></div>
<div class='booktitleinheader'><a href='index.html'>Volume 1: 逻辑基础</a></div>
<ul id='menu'>
   <li class='section_name'><a href='toc.html'>目录</a></li>
   <li class='section_name'><a href='coqindex.html'>索引</a></li>
   <li class='section_name'><a href='deps.html'>路线</a></li>
</ul>
</div>

<div id="main">

<h1 class="libtitle">IndPrinciples<span class="subtitle">归纳法则</span></h1>

<div class="code">
</div>

<div class="doc">

<div class="paragraph"> </div>

 在理解了柯里-霍华德同构及其 Coq 实现之后，我们就可以深入学习归纳法则了。 
</div>

<div class="doc">
<a name="lab282"></a><h1 class="section">基础</h1>

<div class="paragraph"> </div>

 每当我们使用 <span class="inlinecode"><span class="id" title="keyword">Inductive</span></span> 来声明数据类型时，Coq 就会自动为该类型生成
    <i>'归纳法则'</i>。这个归纳法则也是定理：如果 <span class="inlinecode"><span class="id" title="var">t</span></span> 是归纳定义的，那么对应的
    归纳法则被称作 <span class="inlinecode"><span class="id" title="var">t_ind</span></span>。这是自然数的归纳法则： 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#nat_ind"><span class="id" title="definition">nat_ind</span></a>.<br/>
<span class="comment">(*&nbsp;&nbsp;===&gt;&nbsp;nat_ind&nbsp;:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;P&nbsp;:&nbsp;nat&nbsp;<span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span>&nbsp;Prop,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P&nbsp;0&nbsp;&nbsp;<span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(forall&nbsp;n&nbsp;:&nbsp;nat,&nbsp;P&nbsp;n&nbsp;<span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span>&nbsp;P&nbsp;(S&nbsp;n))&nbsp;&nbsp;<span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;n&nbsp;:&nbsp;nat,&nbsp;P&nbsp;n&nbsp;&nbsp;*)</span><br/>
</div>

<div class="doc">
In English: Suppose <span class="inlinecode"><span class="id" title="var">P</span></span> is a property of natural numbers (that is,
      <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> is a <span class="inlinecode"><span class="id" title="keyword">Prop</span></span> for every <span class="inlinecode"><span class="id" title="var">n</span></span>). To show that <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> holds of all
      <span class="inlinecode"><span class="id" title="var">n</span></span>, it suffices to show:

<div class="paragraph"> </div>

<ul class="doclist">
<li> <span class="inlinecode"><span class="id" title="var">P</span></span> holds of <span class="inlinecode">0</span>

</li>
<li> for any <span class="inlinecode"><span class="id" title="var">n</span></span>, if <span class="inlinecode"><span class="id" title="var">P</span></span> holds of <span class="inlinecode"><span class="id" title="var">n</span></span>, then <span class="inlinecode"><span class="id" title="var">P</span></span> holds of <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span>. 
</li>
</ul>

<div class="paragraph"> </div>

 <span class="inlinecode"><span class="id" title="tactic">induction</span></span> 利用归纳法则，执行 <span class="inlinecode"><span class="id" title="tactic">apply</span></span> <span class="inlinecode"><span class="id" title="var">t_ind</span></span> 等策略。
    为了清楚地理解这一点，让我们直接使用 <span class="inlinecode"><span class="id" title="tactic">apply</span></span> <span class="inlinecode"><span class="id" title="var">nat_ind</span></span> 而非 <span class="inlinecode"><span class="id" title="tactic">induction</span></span>
    策略来证明。例如，<a href="Induction.html"><span class="inlineref">Induction</span></a> 一章中 <span class="inlinecode"><span class="id" title="var">mult_0_r'</span></span> 定理的另一种证明如下所示。 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="mult_0_r'"><span class="id" title="lemma">mult_0_r'</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span>:<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="IndPrinciples.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Peano.html#697e4695610f677ae98a52af81f779d<sub>2</sub>"><span class="id" title="notation">×</span></a> 0 <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> 0.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#nat_ind"><span class="id" title="definition">nat_ind</span></a>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;n&nbsp;=&nbsp;O&nbsp;*)</span> <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;n&nbsp;=&nbsp;S&nbsp;n'&nbsp;*)</span> <span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">intros</span> <span class="id" title="var">n'</span> <span class="id" title="var">IHn'</span>. <span class="id" title="tactic">rewrite</span> → <span class="id" title="var">IHn'</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
这个证明基本上等同于之前的，但有几点区别值得注意。

<div class="paragraph"> </div>

    首先，在证明的归纳步骤（<span class="inlinecode">&quot;<span class="id" title="var">S</span>&quot;</span> 情形）中，我们不得不手动管理变量名（即 <span class="inlinecode"><span class="id" title="tactic">intros</span></span>），
    而 <span class="inlinecode"><span class="id" title="tactic">induction</span></span> 会自动完成这些。

<div class="paragraph"> </div>

    其次，在应用 <span class="inlinecode"><span class="id" title="var">nat_ind</span></span> 之前我们没有在上下文中引入 <span class="inlinecode"><span class="id" title="var">n</span></span> —— <span class="inlinecode"><span class="id" title="var">nat_ind</span></span> 的结论
    是一个带有量词的公式，<span class="inlinecode"><span class="id" title="tactic">apply</span></span> 需要这个结论精确地匹配当前证明目标状态的形状，包括其中的量词。
    相反，<span class="inlinecode"><span class="id" title="tactic">induction</span></span> 策略对于上下文中的变量或目标中由量词引入的变量都适用。

<div class="paragraph"> </div>

    第三，我们必须手动为 <span class="inlinecode"><span class="id" title="tactic">apply</span></span> 提供归纳法则，而 <span class="inlinecode"><span class="id" title="tactic">induction</span></span> 可以自己解决它。

<div class="paragraph"> </div>

    相比于直接使用 <span class="inlinecode"><span class="id" title="var">nat_ind</span></span> 这样的归纳法则，在实践中使用 <span class="inlinecode"><span class="id" title="tactic">induction</span></span> 更加方便。
    但重要的是认识到除了这一点变量名的管理工作，我们在做的其实就是应用 <span class="inlinecode"><span class="id" title="var">nat_ind</span></span>。 
<div class="paragraph"> </div>

<a name="lab283"></a><h4 class="section">练习：2 星, standard, optional (plus_one_r')</h4>
 请不使用 <span class="inlinecode"><span class="id" title="tactic">induction</span></span> 策略来完成这个证明。 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="plus_one_r'"><span class="id" title="lemma">plus_one_r'</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span>:<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="IndPrinciples.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Peano.html#b3eea360671e1b32b18a26e15b3aace3"><span class="id" title="notation">+</span></a> 1 <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> <a class="idref" href="IndPrinciples.html#n"><span class="id" title="variable">n</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" title="var">Admitted</span>.<br/>
<font size=-2>&#9744;</font>
</div>

<div class="doc"> 
<div class="paragraph"> </div>

 Coq 为每一个 <span class="inlinecode"><span class="id" title="keyword">Inductive</span></span> 定义的数据类型生成了归纳法则，包括那些非递归的。
    尽管我们不需要归纳，便可证明非递归数据类型的性质，但归纳原理仍可用来证明其性质；
    给定类型，及关于该类型所有值的性质，归纳原理提供了证明该性质的方法。 
<div class="paragraph"> </div>

 这些生成的原则都具有类似的模式。如果我们定义了带有构造子 <span class="inlinecode"><span class="id" title="var">c<sub>1</sub></span></span> ... <span class="inlinecode"><span class="id" title="var">cn</span></span>
    的类型 <span class="inlinecode"><span class="id" title="var">t</span></span>，那么 Coq 会生成形如下文的定理：
<br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">t_ind</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">P</span> : <span class="id" title="var">t</span> → <span class="id" title="keyword">Prop</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;... <span class="id" title="tactic">case</span> <span class="id" title="keyword">for</span> <span class="id" title="var">c<sub>1</sub></span> ... →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;... <span class="id" title="tactic">case</span> <span class="id" title="keyword">for</span> <span class="id" title="var">c<sub>2</sub></span> ... → ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;... <span class="id" title="tactic">case</span> <span class="id" title="keyword">for</span> <span class="id" title="var">cn</span> ... →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <span class="id" title="var">n</span> : <span class="id" title="var">t</span>, <span class="id" title="var">P</span> <span class="id" title="var">n</span>
<div class="paragraph"> </div>

</span>    每个情形具体的形状取决于对应构造子的参数。 
<div class="paragraph"> </div>

 在尝试总结出一般规律前，让我们先来看看更多的例子。
    首先是一个无参数构造子的例子： 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <a name="time"><span class="id" title="inductive">time</span></a> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;| <a name="day"><span class="id" title="constructor">day</span></a><br/>
&nbsp;&nbsp;| <a name="night"><span class="id" title="constructor">night</span></a>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Check</span> <a class="idref" href="IndPrinciples.html#time_ind"><span class="id" title="definition">time_ind</span></a>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;time_ind&nbsp;:&nbsp;forall&nbsp;P&nbsp;:&nbsp;time&nbsp;<span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span>&nbsp;Prop,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P&nbsp;day&nbsp;<span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P&nbsp;night&nbsp;<span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;t&nbsp;:&nbsp;time,&nbsp;P&nbsp;t&nbsp;*)</span><br/>
</div>

<div class="doc">
<a name="lab284"></a><h4 class="section">练习：1 星, standard, optional (rgb)</h4>
 对如下数据类型，请写出 Coq 将会生成的归纳法则。
    先在纸上或注释内写下你的答案，然后同 Coq 打印出的结果比较。 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <a name="rgb"><span class="id" title="inductive">rgb</span></a> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;| <a name="red"><span class="id" title="constructor">red</span></a><br/>
&nbsp;&nbsp;| <a name="green"><span class="id" title="constructor">green</span></a><br/>
&nbsp;&nbsp;| <a name="blue"><span class="id" title="constructor">blue</span></a>.<br/>
<span class="id" title="keyword">Check</span> <a class="idref" href="IndPrinciples.html#rgb_ind"><span class="id" title="definition">rgb_ind</span></a>.<br/>
<font size=-2>&#9744;</font>
</div>

<div class="doc"> 
<div class="paragraph"> </div>

 下文例子中，有一个构造子调取多个参数。
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <a name="natlist"><span class="id" title="inductive">natlist</span></a> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;| <a name="nnil"><span class="id" title="constructor">nnil</span></a><br/>
&nbsp;&nbsp;| <a name="ncons"><span class="id" title="constructor">ncons</span></a> (<span class="id" title="var">n</span> : <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>) (<span class="id" title="var">l</span> : <a class="idref" href="IndPrinciples.html#natlist"><span class="id" title="inductive">natlist</span></a>).<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Check</span> <a class="idref" href="IndPrinciples.html#natlist_ind"><span class="id" title="definition">natlist_ind</span></a>.<br/>
<span class="comment">(*&nbsp;===&gt;<br/>
&nbsp;&nbsp;&nbsp;natlist_ind&nbsp;:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;P&nbsp;:&nbsp;natlist&nbsp;<span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span>&nbsp;Prop,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P&nbsp;nnil&nbsp;&nbsp;<span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(forall&nbsp;(n&nbsp;:&nbsp;nat)&nbsp;(l&nbsp;:&nbsp;natlist),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P&nbsp;l&nbsp;<span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span>&nbsp;P&nbsp;(ncons&nbsp;n&nbsp;l))&nbsp;<span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;l&nbsp;:&nbsp;natlist,&nbsp;P&nbsp;l&nbsp;*)</span><br/>
</div>

<div class="doc">
<a name="lab285"></a><h4 class="section">练习：1 星, standard, optional (natlist1)</h4>
 假设我们写下的定义和上面的有一些区别： 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <a name="natlist1"><span class="id" title="inductive">natlist1</span></a> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;| <a name="nnil1"><span class="id" title="constructor">nnil1</span></a><br/>
&nbsp;&nbsp;| <a name="nsnoc1"><span class="id" title="constructor">nsnoc1</span></a> (<span class="id" title="var">l</span> : <a class="idref" href="IndPrinciples.html#natlist1"><span class="id" title="inductive">natlist1</span></a>) (<span class="id" title="var">n</span> : <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>).<br/>
</div>

<div class="doc">
现在归纳法则会是什么呢？  <font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

 通常，为归纳类型 <span class="inlinecode"><span class="id" title="var">t</span></span> 生成的归纳法则形式如下：

<div class="paragraph"> </div>

<ul class="doclist">
<li> 每个构造子 <span class="inlinecode"><span class="id" title="var">c</span></span> 都会生成归纳法则中的一种情况

</li>
<li> 若 <span class="inlinecode"><span class="id" title="var">c</span></span> 不接受参数，该情况为
<br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;“<span class="id" title="var">P</span> 对 <span class="id" title="var">c</span> 成立”
<div class="paragraph"> </div>

</span>
</li>
<li> 若 <span class="inlinecode"><span class="id" title="var">c</span></span> 接受参数 <span class="inlinecode"><span class="id" title="var">x<sub>1</sub></span>:<span class="id" title="var">a<sub>1</sub></span></span> ... <span class="inlinecode"><span class="id" title="var">xn</span>:<span class="id" title="var">an</span></span>，该情况为：
<br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;“对于所有的 <span class="id" title="var">x<sub>1</sub></span>:<span class="id" title="var">a<sub>1</sub></span> ... <span class="id" title="var">xn</span>:<span class="id" title="var">an</span>，<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;若 [<span class="id" title="var">P</span>] 对每个类型为 [<span class="id" title="var">t</span>] 的函数都成立，<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;则 [<span class="id" title="var">P</span>] 对于 [<span class="id" title="var">c</span> <span class="id" title="var">x<sub>1</sub></span> ... <span class="id" title="var">xn</span>] 成立”
<div class="paragraph"> </div>

</span>
</li>
</ul>

<div class="paragraph"> </div>

<a name="lab286"></a><h4 class="section">练习：1 星, standard, optional (booltree_ind)</h4>
 对如下数据类型，请写出 Coq 将会生成的归纳法则。
   （与之前一样，先在纸上或注释内写下你的答案，然后同 Coq 打印出的结果比较。） 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <a name="booltree"><span class="id" title="inductive">booltree</span></a> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;| <a name="bt_empty"><span class="id" title="constructor">bt_empty</span></a><br/>
&nbsp;| <a name="bt_leaf"><span class="id" title="constructor">bt_leaf</span></a> (<span class="id" title="var">b</span> : <a class="idref" href="Basics.html#bool"><span class="id" title="inductive">bool</span></a>)<br/>
&nbsp;| <a name="bt_branch"><span class="id" title="constructor">bt_branch</span></a> (<span class="id" title="var">b</span> : <a class="idref" href="Basics.html#bool"><span class="id" title="inductive">bool</span></a>) (<span class="id" title="var">t<sub>1</sub></span> <span class="id" title="var">t<sub>2</sub></span> : <a class="idref" href="IndPrinciples.html#booltree"><span class="id" title="inductive">booltree</span></a>).<br/>
<font size=-2>&#9744;</font>
</div>

<div class="doc"> 
<div class="paragraph"> </div>

<a name="lab287"></a><h4 class="section">练习：1 星, standard, optional (ex_set)</h4>
 这是对一个归纳定义的集合的归纳法则。
<br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">ExSet_ind</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <span class="id" title="var">P</span> : <span class="id" title="var">ExSet</span> → <span class="id" title="keyword">Prop</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">∀</span> <span class="id" title="var">b</span> : <span class="id" title="var">bool</span>, <span class="id" title="var">P</span> (<span class="id" title="var">con1</span> <span class="id" title="var">b</span>)) →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">∀</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) (<span class="id" title="var">e</span> : <span class="id" title="var">ExSet</span>), <span class="id" title="var">P</span> <span class="id" title="var">e</span> → <span class="id" title="var">P</span> (<span class="id" title="var">con2</span> <span class="id" title="var">n</span> <span class="id" title="var">e</span>)) →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <span class="id" title="var">e</span> : <span class="id" title="var">ExSet</span>, <span class="id" title="var">P</span> <span class="id" title="var">e</span>
<div class="paragraph"> </div>

</span>    请写出使用 <span class="inlinecode"><span class="id" title="keyword">Inductive</span></span> 来定义的 <span class="inlinecode"><span class="id" title="var">ExSet</span></span>： 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <a name="ExSet"><span class="id" title="inductive">ExSet</span></a> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span><br/>
.<br/>
<font size=-2>&#9744;</font>
</div>

<div class="doc"> 
<div class="paragraph"> </div>

<a name="lab288"></a><h1 class="section">多态</h1>

<div class="paragraph"> </div>

 多态数据结构会是怎样的呢？

<div class="paragraph"> </div>

    归纳定义的多态列表
<br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Inductive</span> <span class="id" title="var">list</span> (<span class="id" title="var">X</span>:<span class="id" title="keyword">Type</span>) : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">nil</span> : <span class="id" title="var">list</span> <span class="id" title="var">X</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">cons</span> : <span class="id" title="var">X</span> → <span class="id" title="var">list</span> <span class="id" title="var">X</span> → <span class="id" title="var">list</span> <span class="id" title="var">X</span>.
<div class="paragraph"> </div>

</span>    同 <span class="inlinecode"><span class="id" title="var">natlist</span></span> 是十分相似的。主要的区别是，这里全部的定义是由集合 <span class="inlinecode"><span class="id" title="var">X</span></span> 所<i>'参数化'</i>的：
    也即，我们定义了<i>'一族'</i>归纳类型 <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">X</span></span>，对于每个 <span class="inlinecode"><span class="id" title="var">X</span></span> 有其对应的类型在此族中。
    （请注意，当 <span class="inlinecode"><span class="id" title="var">list</span></span> 出现在声明体中时，它总是被应用参数 <span class="inlinecode"><span class="id" title="var">X</span></span>。）

<div class="paragraph"> </div>

  归纳法则同样被 <span class="inlinecode"><span class="id" title="var">X</span></span> 所参数化：
<br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">list_ind</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">∀</span> (<span class="id" title="var">X</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">P</span> : <span class="id" title="var">list</span> <span class="id" title="var">X</span> → <span class="id" title="keyword">Prop</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">P</span> [] →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">∀</span> (<span class="id" title="var">x</span> : <span class="id" title="var">X</span>) (<span class="id" title="var">l</span> : <span class="id" title="var">list</span> <span class="id" title="var">X</span>), <span class="id" title="var">P</span> <span class="id" title="var">l</span> → <span class="id" title="var">P</span> (<span class="id" title="var">x</span> :: <span class="id" title="var">l</span>)) →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <span class="id" title="var">l</span> : <span class="id" title="var">list</span> <span class="id" title="var">X</span>, <span class="id" title="var">P</span> <span class="id" title="var">l</span>
<div class="paragraph"> </div>

</span>    请注意归纳法则的<i>'所有部分'</i>都被 <span class="inlinecode"><span class="id" title="var">X</span></span> 所参数化。也即，<span class="inlinecode"><span class="id" title="var">list_ind</span></span> 可认为是一个
    多态函数，当被应用类型 <span class="inlinecode"><span class="id" title="var">X</span></span> 时，返回特化在类型 <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">X</span></span> 上的归纳法则。 
<div class="paragraph"> </div>

<a name="lab289"></a><h4 class="section">练习：1 星, standard, optional (tree)</h4>
 对如下数据类型，请写出 Coq 将会生成的归纳法则，并与 Coq 打印出的结果比较。
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <a name="tree"><span class="id" title="inductive">tree</span></a> (<span class="id" title="var">X</span>:<span class="id" title="keyword">Type</span>) : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;| <a name="leaf"><span class="id" title="constructor">leaf</span></a> (<span class="id" title="var">x</span> : <a class="idref" href="IndPrinciples.html#X"><span class="id" title="variable">X</span></a>)<br/>
&nbsp;&nbsp;| <a name="node"><span class="id" title="constructor">node</span></a> (<span class="id" title="var">t<sub>1</sub></span> <span class="id" title="var">t<sub>2</sub></span> : <a class="idref" href="IndPrinciples.html#tree"><span class="id" title="inductive">tree</span></a> <a class="idref" href="IndPrinciples.html#X"><span class="id" title="variable">X</span></a>).<br/>
<span class="id" title="keyword">Check</span> <a class="idref" href="IndPrinciples.html#tree_ind"><span class="id" title="definition">tree_ind</span></a>.<br/>
<font size=-2>&#9744;</font>
</div>

<div class="doc"> 
<div class="paragraph"> </div>

<a name="lab290"></a><h4 class="section">练习：1 星, standard, optional (mytype)</h4>
 请找到对应于以下归纳法则的归纳定义：
<br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">mytype_ind</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">∀</span> (<span class="id" title="var">X</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">P</span> : <span class="id" title="var">mytype</span> <span class="id" title="var">X</span> → <span class="id" title="keyword">Prop</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">∀</span> <span class="id" title="var">x</span> : <span class="id" title="var">X</span>, <span class="id" title="var">P</span> (<span class="id" title="var">constr1</span> <span class="id" title="var">X</span> <span class="id" title="var">x</span>)) →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">∀</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">P</span> (<span class="id" title="var">constr2</span> <span class="id" title="var">X</span> <span class="id" title="var">n</span>)) →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">∀</span> <span class="id" title="var">m</span> : <span class="id" title="var">mytype</span> <span class="id" title="var">X</span>, <span class="id" title="var">P</span> <span class="id" title="var">m</span> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">P</span> (<span class="id" title="var">constr3</span> <span class="id" title="var">X</span> <span class="id" title="var">m</span> <span class="id" title="var">n</span>)) →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <span class="id" title="var">m</span> : <span class="id" title="var">mytype</span> <span class="id" title="var">X</span>, <span class="id" title="var">P</span> <span class="id" title="var">m</span>
<div class="paragraph"> </div>

</span> <font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab291"></a><h4 class="section">练习：1 星, standard, optional (foo)</h4>
 请找到对应于以下归纳法则的归纳定义：
<br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">foo_ind</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">∀</span> (<span class="id" title="var">X</span> <span class="id" title="var">Y</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">P</span> : <span class="id" title="var">foo</span> <span class="id" title="var">X</span> <span class="id" title="var">Y</span> → <span class="id" title="keyword">Prop</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">∀</span> <span class="id" title="var">x</span> : <span class="id" title="var">X</span>, <span class="id" title="var">P</span> (<span class="id" title="var">bar</span> <span class="id" title="var">X</span> <span class="id" title="var">Y</span> <span class="id" title="var">x</span>)) →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">∀</span> <span class="id" title="var">y</span> : <span class="id" title="var">Y</span>, <span class="id" title="var">P</span> (<span class="id" title="var">baz</span> <span class="id" title="var">X</span> <span class="id" title="var">Y</span> <span class="id" title="var">y</span>)) →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">∀</span> <span class="id" title="var">f<sub>1</sub></span> : <span class="id" title="var">nat</span> → <span class="id" title="var">foo</span> <span class="id" title="var">X</span> <span class="id" title="var">Y</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">∀</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">P</span> (<span class="id" title="var">f<sub>1</sub></span> <span class="id" title="var">n</span>)) → <span class="id" title="var">P</span> (<span class="id" title="var">quux</span> <span class="id" title="var">X</span> <span class="id" title="var">Y</span> <span class="id" title="var">f<sub>1</sub></span>)) →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <span class="id" title="var">f<sub>2</sub></span> : <span class="id" title="var">foo</span> <span class="id" title="var">X</span> <span class="id" title="var">Y</span>, <span class="id" title="var">P</span> <span class="id" title="var">f<sub>2</sub></span>
<div class="paragraph"> </div>

</span> <font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab292"></a><h4 class="section">练习：1 星, standard, optional (foo')</h4>
 请考虑以下归纳定义： 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <a name="foo'"><span class="id" title="inductive">foo'</span></a> (<span class="id" title="var">X</span>:<span class="id" title="keyword">Type</span>) : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;| <a name="C<sub>1</sub>"><span class="id" title="constructor">C<sub>1</sub></span></a> (<span class="id" title="var">l</span> : <a class="idref" href="Poly.html#list"><span class="id" title="inductive">list</span></a> <a class="idref" href="IndPrinciples.html#X"><span class="id" title="variable">X</span></a>) (<span class="id" title="var">f</span> : <a class="idref" href="IndPrinciples.html#foo'"><span class="id" title="inductive">foo'</span></a> <a class="idref" href="IndPrinciples.html#X"><span class="id" title="variable">X</span></a>)<br/>
&nbsp;&nbsp;| <a name="C<sub>2</sub>"><span class="id" title="constructor">C<sub>2</sub></span></a>.<br/>
</div>

<div class="doc">
Coq 会为 <span class="inlinecode"><span class="id" title="var">foo'</span></span> 生成什么归纳法则？请填写下面的空白，并使用 Coq 检查你的答案。
<br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">foo'_ind</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">∀</span> (<span class="id" title="var">X</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">P</span> : <span class="id" title="var">foo'</span> <span class="id" title="var">X</span> → <span class="id" title="keyword">Prop</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">∀</span> (<span class="id" title="var">l</span> : <span class="id" title="var">list</span> <span class="id" title="var">X</span>) (<span class="id" title="var">f</span> : <span class="id" title="var">foo'</span> <span class="id" title="var">X</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">_______________________</span> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">_______________________</span>   ) →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">___________________________________________</span> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <span class="id" title="var">f</span> : <span class="id" title="var">foo'</span> <span class="id" title="var">X</span>, <span class="id" title="var">________________________</span>
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

 <font size=-2>&#9744;</font> 
</div>

<div class="doc">
<a name="lab293"></a><h1 class="section">归纳假设</h1>

<div class="paragraph"> </div>

 “归纳假设”是在什么语境下出现的呢？

<div class="paragraph"> </div>

    对于数的归纳法则：
<br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <span class="id" title="var">P</span> : <span class="id" title="var">nat</span> → <span class="id" title="keyword">Prop</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">P</span> 0  →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">∀</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">P</span> <span class="id" title="var">n</span> → <span class="id" title="var">P</span> (<span class="id" title="var">S</span> <span class="id" title="var">n</span>))  →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">P</span> <span class="id" title="var">n</span>
<div class="paragraph"> </div>

</span>  是一个对于所有命题 <span class="inlinecode"><span class="id" title="var">P</span></span> （或更严格地说，对由数字 <span class="inlinecode"><span class="id" title="var">n</span></span> 索引的所有命题 <span class="inlinecode"><span class="id" title="var">P</span></span>）
  都成立的泛化陈述。每次使用这个原理，我们将 <span class="inlinecode"><span class="id" title="var">P</span></span> 特化为一个类型为 <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>
  的表达式。

<div class="paragraph"> </div>

  通过命名这个表达式，我们可以让归纳证明更加明确。比如，除了陈述定理
  <span class="inlinecode"><span class="id" title="var">mult_0_r</span></span> 为 “<span class="inlinecode"><span class="id" title="keyword">∀</span></span> <span class="inlinecode"><span class="id" title="var">n</span>,</span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">×</span> <span class="inlinecode">0</span> <span class="inlinecode">=</span> <span class="inlinecode">0</span>”，我们还可以写成
  “<span class="inlinecode"><span class="id" title="keyword">∀</span></span> <span class="inlinecode"><span class="id" title="var">n</span>,</span> <span class="inlinecode"><span class="id" title="var">P_m0r</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span>”，其中 <span class="inlinecode"><span class="id" title="var">O_m0r</span></span> 定义为…… 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <a name="P_m0r"><span class="id" title="definition">P_m0r</span></a> (<span class="id" title="var">n</span>:<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>) : <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;<a class="idref" href="IndPrinciples.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Peano.html#697e4695610f677ae98a52af81f779d<sub>2</sub>"><span class="id" title="notation">×</span></a> 0 <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> 0.<br/>
</div>

<div class="doc">
……或等价地： 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <a name="P_m0r'"><span class="id" title="definition">P_m0r'</span></a> : <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">fun</span> <span class="id" title="var">n</span> ⇒ <a class="idref" href="IndPrinciples.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Peano.html#697e4695610f677ae98a52af81f779d<sub>2</sub>"><span class="id" title="notation">×</span></a> 0 <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> 0.<br/>
</div>

<div class="doc">
现在看看 <span class="inlinecode"><span class="id" title="var">P_m0r</span></span> 在证明中出现在哪里。 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="mult_0_r''"><span class="id" title="lemma">mult_0_r''</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span>:<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="IndPrinciples.html#P_m0r"><span class="id" title="definition">P_m0r</span></a> <a class="idref" href="IndPrinciples.html#n"><span class="id" title="variable">n</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#nat_ind"><span class="id" title="definition">nat_ind</span></a>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;n&nbsp;=&nbsp;O&nbsp;*)</span> <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;n&nbsp;=&nbsp;S&nbsp;n'&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;请注意目前的证明状态！&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">IHn</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <a class="idref" href="IndPrinciples.html#P_m0r"><span class="id" title="definition">P_m0r</span></a> <span class="id" title="tactic">in</span> <span class="id" title="var">IHn</span>. <span class="id" title="tactic">unfold</span> <a class="idref" href="IndPrinciples.html#P_m0r"><span class="id" title="definition">P_m0r</span></a>. <span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">IHn</span>. <span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
通常我们并不会在证明中额外地为命题命名，但有意地进行一两个练习
    可以帮助我们清晰地看到哪个是归纳假设。
    如果对 <span class="inlinecode"><span class="id" title="var">n</span></span> 归纳来证明 <span class="inlinecode"><span class="id" title="keyword">∀</span></span> <span class="inlinecode"><span class="id" title="var">n</span>,</span> <span class="inlinecode"><span class="id" title="var">P_m0r</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span>（使用 <span class="inlinecode"><span class="id" title="tactic">induction</span></span>
    或 <span class="inlinecode"><span class="id" title="tactic">apply</span></span> <span class="inlinecode"><span class="id" title="var">nat_ind</span></span>），可以看到第一个子目标要求我们证明 <span class="inlinecode"><span class="id" title="var">P_m0r</span></span> <span class="inlinecode">0</span>
    （“<span class="inlinecode"><span class="id" title="var">P</span></span> 对零成立”），而第二个子目标要求我们证明 <span class="inlinecode"><span class="id" title="keyword">∀</span></span> <span class="inlinecode"><span class="id" title="var">n'</span>,</span> <span class="inlinecode"><span class="id" title="var">P_m0r</span></span> <span class="inlinecode"><span class="id" title="var">n'</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">P_m0r</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n'</span>)</span>
    （也即，“<span class="inlinecode"><span class="id" title="var">P</span></span> 对 <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n'</span></span> 成立仅当其对 <span class="inlinecode"><span class="id" title="var">n'</span></span> 成立”，或者说，“<span class="inlinecode"><span class="id" title="var">P</span></span> 被 <span class="inlinecode"><span class="id" title="var">S</span></span> 保持”）。
    <i>'归纳假设'</i>是后一个蕴含式中的前提部分，即假设 <span class="inlinecode"><span class="id" title="var">P</span></span> 对 <span class="inlinecode"><span class="id" title="var">n'</span></span> 成立，这是我们在证明 <span class="inlinecode"><span class="id" title="var">P</span></span>
    对 <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n'</span></span> 的过程中允许使用的。 
</div>

<div class="doc">
<a name="lab294"></a><h1 class="section">深入 <span class="inlinecode"><span class="id" title="tactic">induction</span></span> 策略</h1>

<div class="paragraph"> </div>

 <span class="inlinecode"><span class="id" title="tactic">induction</span></span> 策略事实上为我们做了更多低层次的工作。

<div class="paragraph"> </div>

    请回忆一下自然数归纳法则的非形式化陈述：
<ul class="doclist">
<li> 如果 <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> 是某个涉及到数字 n 的命题，我们想要证明 <span class="inlinecode"><span class="id" title="var">P</span></span> 对于<i>'所有'</i>数字 n
        都成立，我们以如下方式推理：
<ul class="doclist">
<li> 证明 <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">0</span> 成立

</li>
<li> 证明如果 <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">n'</span></span> 成立，那么 <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n'</span>)</span> 成立

</li>
<li> 得出结论 <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> 对所有 n 成立。

</li>
</ul>

</li>
</ul>
    因此，当以 <span class="inlinecode"><span class="id" title="tactic">intros</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> 和 <span class="inlinecode"><span class="id" title="tactic">induction</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> 开始一个证明时，我们首先在告诉 Coq
    考虑一个<i>'特殊的'</i> <span class="inlinecode"><span class="id" title="var">n</span></span>（通过引入到上下文中），然后告诉它证明一些关于
    <i>'全体'</i>数字的性质（通过使用归纳）。

<div class="paragraph"> </div>

  在这种情况下，Coq 事实上在内部“再次一般化（re-generalize）”了我们进行归纳的变量。
    比如说，起初证明 <span class="inlinecode"><span class="id" title="var">plus</span></span> 的结合性时……  
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="plus_assoc'"><span class="id" title="lemma">plus_assoc'</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> <span class="id" title="var">p</span> : <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="IndPrinciples.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Peano.html#b3eea360671e1b32b18a26e15b3aace3"><span class="id" title="notation">+</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Peano.html#b3eea360671e1b32b18a26e15b3aace3"><span class="id" title="notation">(</span></a><a class="idref" href="IndPrinciples.html#m"><span class="id" title="variable">m</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Peano.html#b3eea360671e1b32b18a26e15b3aace3"><span class="id" title="notation">+</span></a> <a class="idref" href="IndPrinciples.html#p"><span class="id" title="variable">p</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Peano.html#b3eea360671e1b32b18a26e15b3aace3"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Peano.html#b3eea360671e1b32b18a26e15b3aace3"><span class="id" title="notation">(</span></a><a class="idref" href="IndPrinciples.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Peano.html#b3eea360671e1b32b18a26e15b3aace3"><span class="id" title="notation">+</span></a> <a class="idref" href="IndPrinciples.html#m"><span class="id" title="variable">m</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Peano.html#b3eea360671e1b32b18a26e15b3aace3"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Peano.html#b3eea360671e1b32b18a26e15b3aace3"><span class="id" title="notation">+</span></a> <a class="idref" href="IndPrinciples.html#p"><span class="id" title="variable">p</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;……首先，我们引入全部&nbsp;3&nbsp;个变量到上下文中，或者说是<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;“考虑任意的&nbsp;<span class="inlinecode"><span class="id" title="var">n</span></span>，<span class="inlinecode"><span class="id" title="var">m</span></span>&nbsp;和&nbsp;<span class="inlinecode"><span class="id" title="var">p</span></span>……”&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> <span class="id" title="var">p</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;……现在，我们用&nbsp;<span class="inlinecode"><span class="id" title="tactic">induction</span></span>&nbsp;策略来证明&nbsp;<span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（也即，<span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode">(<span class="id" title="var">m</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">p</span>)</span> <span class="inlinecode">=</span> <span class="inlinecode">(<span class="id" title="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">m</span>)</span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">p</span></span>）对全体的&nbsp;<span class="inlinecode"><span class="id" title="var">n</span></span>&nbsp;成立，<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;也因此对于当前上下文中特殊的&nbsp;<span class="inlinecode"><span class="id" title="var">n</span></span>&nbsp;也成立。&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">n</span> <span class="id" title="keyword">as</span> [| <span class="id" title="var">n'</span>].<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;n&nbsp;=&nbsp;O&nbsp;*)</span> <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;n&nbsp;=&nbsp;S&nbsp;n'&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">rewrite</span> → <span class="id" title="var">IHn'</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
对目标中含有量词的变量应用 <span class="inlinecode"><span class="id" title="tactic">induction</span></span> 同样可以工作。
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="plus_comm'"><span class="id" title="lemma">plus_comm'</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="IndPrinciples.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Peano.html#b3eea360671e1b32b18a26e15b3aace3"><span class="id" title="notation">+</span></a> <a class="idref" href="IndPrinciples.html#m"><span class="id" title="variable">m</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="IndPrinciples.html#m"><span class="id" title="variable">m</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Peano.html#b3eea360671e1b32b18a26e15b3aace3"><span class="id" title="notation">+</span></a> <a class="idref" href="IndPrinciples.html#n"><span class="id" title="variable">n</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">n</span> <span class="id" title="keyword">as</span> [| <span class="id" title="var">n'</span>].<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;n&nbsp;=&nbsp;O&nbsp;*)</span> <span class="id" title="tactic">intros</span> <span class="id" title="var">m</span>. <span class="id" title="tactic">rewrite</span> &lt;- <a class="idref" href="Induction.html#plus_n_O"><span class="id" title="lemma">plus_n_O</span></a>. <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;n&nbsp;=&nbsp;S&nbsp;n'&nbsp;*)</span> <span class="id" title="tactic">intros</span> <span class="id" title="var">m</span>. <span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">rewrite</span> → <span class="id" title="var">IHn'</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> &lt;- <a class="idref" href="Induction.html#plus_n_Sm"><span class="id" title="axiom">plus_n_Sm</span></a>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
请注意，使用 <span class="inlinecode"><span class="id" title="tactic">induction</span></span> 后 <span class="inlinecode"><span class="id" title="var">m</span></span> 在目标中仍然是绑定的，
    也即，归纳证明的陈述是以 <span class="inlinecode"><span class="id" title="keyword">∀</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span> 开始的。

<div class="paragraph"> </div>

    如果我们对目标中其他量词<i>'后'</i>的量化变量使用 <span class="inlinecode"><span class="id" title="tactic">induction</span></span>，那么它会自动
    引入全部被量词绑定的变量到上下文中。 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="plus_comm''"><span class="id" title="lemma">plus_comm''</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="IndPrinciples.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Peano.html#b3eea360671e1b32b18a26e15b3aace3"><span class="id" title="notation">+</span></a> <a class="idref" href="IndPrinciples.html#m"><span class="id" title="variable">m</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="IndPrinciples.html#m"><span class="id" title="variable">m</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Peano.html#b3eea360671e1b32b18a26e15b3aace3"><span class="id" title="notation">+</span></a> <a class="idref" href="IndPrinciples.html#n"><span class="id" title="variable">n</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;这次让我们对&nbsp;<span class="inlinecode"><span class="id" title="var">m</span></span>&nbsp;而非&nbsp;<span class="inlinecode"><span class="id" title="var">n</span></span>&nbsp;进行归纳……&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">m</span> <span class="id" title="keyword">as</span> [| <span class="id" title="var">m'</span>]. <span class="comment">(*&nbsp;<span class="inlinecode"><span class="id" title="var">n</span></span>&nbsp;已经引入到上下文中了&nbsp;*)</span><br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;m&nbsp;=&nbsp;O&nbsp;*)</span> <span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">rewrite</span> &lt;- <a class="idref" href="Induction.html#plus_n_O"><span class="id" title="lemma">plus_n_O</span></a>. <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;m&nbsp;=&nbsp;S&nbsp;m'&nbsp;*)</span> <span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">rewrite</span> &lt;- <span class="id" title="var">IHm'</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> &lt;- <a class="idref" href="Induction.html#plus_n_Sm"><span class="id" title="axiom">plus_n_Sm</span></a>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<a name="lab295"></a><h4 class="section">练习：1 星, standard, optional (plus_explicit_prop)</h4>
 以类似 <span class="inlinecode"><span class="id" title="var">mult_0_r''</span></span> 的方式来重写 <span class="inlinecode"><span class="id" title="var">plus_assoc'</span></span>，<span class="inlinecode"><span class="id" title="var">plus_comm'</span></span> 和它们的证明——
    对于每个定理，给出一个明确的命题的 <span class="inlinecode"><span class="id" title="keyword">Definition</span></span>，陈述定理并用归纳法证明这个
    定义的命题。 
</div>
<div class="code">

<br/>
<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span><br/>
<font size=-2>&#9744;</font>
</div>


<div class="doc">
<a name="lab296"></a><h1 class="section"><span class="inlinecode"><span class="id" title="keyword">Prop</span></span> 中的归纳法则</h1>

<div class="paragraph"> </div>

 之前，我们仔细学习了 Coq 为归纳定义的<i>'集合'</i>生成的归纳法则。 像 <span class="inlinecode"><span class="id" title="var">even</span></span>
    这样的归纳定义<i>'命题'</i>的归纳法则会复杂一点点。就全部归纳法则来说，我们想要
    通过使用 <span class="inlinecode"><span class="id" title="var">even</span></span> 的归纳法则并归纳地考虑 <span class="inlinecode"><span class="id" title="var">even</span></span> 中所有可能的形式来证明一些东西。
    然而，直观地讲，我们想要证明的东西并不是关于<i>'证据'</i>的陈述，而是关于
    <i>'自然数'</i>的陈述：因此，我们想要让归纳法则允许通过对证据进行归纳来
    证明关于数字的性质。例如：

<div class="paragraph"> </div>

 根据我们前面所讲，你可能会期待这样归纳定义的 <span class="inlinecode"><span class="id" title="var">even</span></span>……
<br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Inductive</span> <span class="id" title="var">even</span> : <span class="id" title="var">nat</span> → <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">ev_0</span> : <span class="id" title="var">even</span> 0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">ev_SS</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">even</span> <span class="id" title="var">n</span> → <span class="id" title="var">even</span> (<span class="id" title="var">S</span> (<span class="id" title="var">S</span> <span class="id" title="var">n</span>)).
<div class="paragraph"> </div>

</span>    ……并给我们下面这样的归纳法则……
<br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">ev_ind_max</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">P</span> : (<span class="id" title="keyword">∀</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">even</span> <span class="id" title="var">n</span> → <span class="id" title="keyword">Prop</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">P</span> <span class="id" title="var">O</span> <span class="id" title="var">ev_0</span> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">∀</span> (<span class="id" title="var">m</span> : <span class="id" title="var">nat</span>) (<span class="id" title="var">E</span> : <span class="id" title="var">even</span> <span class="id" title="var">m</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">P</span> <span class="id" title="var">m</span> <span class="id" title="var">E</span> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">P</span> (<span class="id" title="var">S</span> (<span class="id" title="var">S</span> <span class="id" title="var">m</span>)) (<span class="id" title="var">ev_SS</span> <span class="id" title="var">m</span> <span class="id" title="var">E</span>)) →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">∀</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) (<span class="id" title="var">E</span> : <span class="id" title="var">even</span> <span class="id" title="var">n</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">P</span> <span class="id" title="var">n</span> <span class="id" title="var">E</span>
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>


<div class="paragraph"> </div>

   ……因为：

<div class="paragraph"> </div>

<ul class="doclist">
<li> 由于 <span class="inlinecode"><span class="id" title="var">even</span></span> 被自然数 <span class="inlinecode"><span class="id" title="var">n</span></span> 所索引（任何 <span class="inlinecode"><span class="id" title="var">even</span></span> 对象 <span class="inlinecode"><span class="id" title="var">E</span></span> 都是某个自然数 <span class="inlinecode"><span class="id" title="var">n</span></span>
       是偶数的证据），且命题 <span class="inlinecode"><span class="id" title="var">P</span></span> 同时被 <span class="inlinecode"><span class="id" title="var">n</span></span> 和 <span class="inlinecode"><span class="id" title="var">E</span></span> 所参数化——因此，被用于证明断言的
       归纳法则同时涉及到一个偶数和这个数是偶数的证据。

<div class="paragraph"> </div>


</li>
<li> 由于有两种方法来给出偶数性质的证据（因为 <span class="inlinecode"><span class="id" title="var">even</span></span> 有两个构造子），我们应用归纳法则生成
       了两个子目标：

<div class="paragraph"> </div>

<ul class="doclist">
<li> 须证明 <span class="inlinecode"><span class="id" title="var">P</span></span> 对 <span class="inlinecode">0</span> 和 <span class="inlinecode"><span class="id" title="var">ev_0</span></span> 成立。

<div class="paragraph"> </div>


</li>
<li> 须证明，当 <span class="inlinecode"><span class="id" title="var">m</span></span> 是一个自然数且 <span class="inlinecode"><span class="id" title="var">E</span></span> 是其偶数性质的证据，如果 <span class="inlinecode"><span class="id" title="var">P</span></span>
           对 <span class="inlinecode"><span class="id" title="var">m</span></span> 和 <span class="inlinecode"><span class="id" title="var">E</span></span> 成立，那么它也对 <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">m</span>)</span> 和 <span class="inlinecode"><span class="id" title="var">ev_SS</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode"><span class="id" title="var">E</span></span> 成立。

<div class="paragraph"> </div>


</li>
</ul>

</li>
<li> 如果这些子目标可以被证明，那么归纳法则告诉我们 <span class="inlinecode"><span class="id" title="var">P</span></span> 对所有的偶数 <span class="inlinecode"><span class="id" title="var">n</span></span>
       和它们的偶数性质 <span class="inlinecode"><span class="id" title="var">E</span></span> 成立。

</li>
</ul>

<div class="paragraph"> </div>

    这比我们通常需要的或想要的更灵活一点：它为我们提供了一种方式证明逻辑断言，
    其断言涉及到一些关于偶数的证据的性质，然而我们真正想要的是证明某些<i>'自然数'</i>
    是偶数这样的性质——我们感兴趣的是关于自然数的断言，而非关于证据。如果对于命题 <span class="inlinecode"><span class="id" title="var">P</span></span>
    的归纳法则仅仅被 <span class="inlinecode"><span class="id" title="var">n</span></span> 所参数化，且其结论是 <span class="inlinecode"><span class="id" title="var">P</span></span> 对所有偶数 <span class="inlinecode"><span class="id" title="var">n</span></span> 成立，那会方便许多：
<br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <span class="id" title="var">P</span> : <span class="id" title="var">nat</span> → <span class="id" title="keyword">Prop</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;... →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">even</span> <span class="id" title="var">n</span> → <span class="id" title="var">P</span> <span class="id" title="var">n</span>
<div class="paragraph"> </div>

</span>    出于这样的原因，Coq 实际上为 <span class="inlinecode"><span class="id" title="var">even</span></span> 生成了简化过的归纳法则： 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Print</span> <a class="idref" href="IndProp.html#ev"><span class="id" title="inductive">ev</span></a>.<br/>
<span class="comment">(*&nbsp;===&gt;<br/>
Inductive&nbsp;ev&nbsp;:&nbsp;nat&nbsp;<span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span>&nbsp;Prop&nbsp;:=<br/>
&nbsp;&nbsp;|&nbsp;ev_0&nbsp;:&nbsp;ev&nbsp;0<br/>
&nbsp;&nbsp;|&nbsp;ev_SS&nbsp;:&nbsp;forall&nbsp;n&nbsp;:&nbsp;nat,&nbsp;ev&nbsp;n&nbsp;<span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span>&nbsp;ev&nbsp;(S&nbsp;(S&nbsp;n))<br/>
*)</span><br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Check</span> <a class="idref" href="IndProp.html#ev_ind"><span class="id" title="definition">ev_ind</span></a>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;ev_ind<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;forall&nbsp;P&nbsp;:&nbsp;nat&nbsp;<span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span>&nbsp;Prop,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P&nbsp;0&nbsp;<span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(forall&nbsp;n&nbsp;:&nbsp;nat,&nbsp;ev&nbsp;n&nbsp;<span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span>&nbsp;P&nbsp;n&nbsp;<span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span>&nbsp;P&nbsp;(S&nbsp;(S&nbsp;n)))&nbsp;<span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;n&nbsp;:&nbsp;nat,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ev&nbsp;n&nbsp;<span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span>&nbsp;P&nbsp;n&nbsp;*)</span><br/>
</div>

<div class="doc">
请特别注意，Coq 丢弃了命题 <span class="inlinecode"><span class="id" title="var">P</span></span> 参数中的证据项 <span class="inlinecode"><span class="id" title="var">E</span></span>。 
<div class="paragraph"> </div>

 若用自然语言来表述 <span class="inlinecode"><span class="id" title="var">ev_ind</span></span>，则是说：假设 <span class="inlinecode"><span class="id" title="var">P</span></span> 是关于自然数的一个性质
    （也即，<span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> 是一个在全体 <span class="inlinecode"><span class="id" title="var">n</span></span> 上的 <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>）。为了证明当 <span class="inlinecode"><span class="id" title="var">n</span></span> 是偶数时
    <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> 成立，需要证明：

<div class="paragraph"> </div>

<ul class="doclist">
<li> <span class="inlinecode"><span class="id" title="var">P</span></span> 对 <span class="inlinecode">0</span> 成立，

<div class="paragraph"> </div>


</li>
<li> 对任意 <span class="inlinecode"><span class="id" title="var">n</span></span>，如果 <span class="inlinecode"><span class="id" title="var">n</span></span> 是偶数且 <span class="inlinecode"><span class="id" title="var">P</span></span> 对 <span class="inlinecode"><span class="id" title="var">n</span></span> 成立，那么 <span class="inlinecode"><span class="id" title="var">P</span></span> 对 <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n</span>)</span> 成立。 
</li>
</ul>

<div class="paragraph"> </div>

 正如期待的那样，我们可以不使用 <span class="inlinecode"><span class="id" title="tactic">induction</span></span> 而直接应用 <span class="inlinecode"><span class="id" title="var">ev_ind</span></span>。
    比如，我们可以使用它来证明 <span class="inlinecode"><span class="id" title="var">ev'</span></span>（就是在 <a href="IndProp.html"><span class="inlineref">IndProp</span></a>
    一章的练习中那个有点笨拙的偶数性质的定义）等价于更简洁的归纳定义 <span class="inlinecode"><span class="id" title="var">ev</span></span>： 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <a name="ev'"><span class="id" title="inductive">ev'</span></a> : <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <span class="id" title="keyword">Prop</span> :=<br/>
| <a name="ev'_0"><span class="id" title="constructor">ev'_0</span></a> : <a class="idref" href="IndPrinciples.html#ev'"><span class="id" title="inductive">ev'</span></a> 0<br/>
| <a name="ev'_2"><span class="id" title="constructor">ev'_2</span></a> : <a class="idref" href="IndPrinciples.html#ev'"><span class="id" title="inductive">ev'</span></a> 2<br/>
| <a name="ev'_sum"><span class="id" title="constructor">ev'_sum</span></a> <span class="id" title="var">n</span> <span class="id" title="var">m</span> (<span class="id" title="var">Hn</span> : <a class="idref" href="IndPrinciples.html#ev'"><span class="id" title="inductive">ev'</span></a> <a class="idref" href="IndPrinciples.html#n"><span class="id" title="variable">n</span></a>) (<span class="id" title="var">Hm</span> : <a class="idref" href="IndPrinciples.html#ev'"><span class="id" title="inductive">ev'</span></a> <a class="idref" href="IndPrinciples.html#m"><span class="id" title="variable">m</span></a>) : <a class="idref" href="IndPrinciples.html#ev'"><span class="id" title="inductive">ev'</span></a> (<a class="idref" href="IndPrinciples.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Peano.html#b3eea360671e1b32b18a26e15b3aace3"><span class="id" title="notation">+</span></a> <a class="idref" href="IndPrinciples.html#m"><span class="id" title="variable">m</span></a>).<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Theorem</span> <a name="ev_ev'"><span class="id" title="lemma">ev_ev'</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span>, <a class="idref" href="IndProp.html#ev"><span class="id" title="inductive">ev</span></a> <a class="idref" href="IndPrinciples.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="IndPrinciples.html#ev'"><span class="id" title="inductive">ev'</span></a> <a class="idref" href="IndPrinciples.html#n"><span class="id" title="variable">n</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <a class="idref" href="IndProp.html#ev_ind"><span class="id" title="definition">ev_ind</span></a>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;ev_0&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <a class="idref" href="IndPrinciples.html#ev'_0"><span class="id" title="constructor">ev'_0</span></a>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;ev_SS&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">m</span> <span class="id" title="var">Hm</span> <span class="id" title="var">IH</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<a class="idref" href="IndPrinciples.html#ev'_sum"><span class="id" title="constructor">ev'_sum</span></a> 2 <span class="id" title="var">m</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">apply</span> <a class="idref" href="IndPrinciples.html#ev'_2"><span class="id" title="constructor">ev'_2</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">apply</span> <span class="id" title="var">IH</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" title="keyword">Inductive</span></span> 定义的具体形式会影响到 Coq 生成的归纳法则。 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <a name="le<sub>1</sub>"><span class="id" title="inductive">le<sub>1</sub></span></a> : <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a name="le1_n"><span class="id" title="constructor">le1_n</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span>, <a class="idref" href="IndPrinciples.html#le<sub>1</sub>"><span class="id" title="inductive">le<sub>1</sub></span></a> <a class="idref" href="IndPrinciples.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="IndPrinciples.html#n"><span class="id" title="variable">n</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a name="le1_S"><span class="id" title="constructor">le1_S</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span>, <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">(</span></a><a class="idref" href="IndPrinciples.html#le<sub>1</sub>"><span class="id" title="inductive">le<sub>1</sub></span></a> <a class="idref" href="IndPrinciples.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="IndPrinciples.html#m"><span class="id" title="variable">m</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">(</span></a><a class="idref" href="IndPrinciples.html#le<sub>1</sub>"><span class="id" title="inductive">le<sub>1</sub></span></a> <a class="idref" href="IndPrinciples.html#n"><span class="id" title="variable">n</span></a> (<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> <a class="idref" href="IndPrinciples.html#m"><span class="id" title="variable">m</span></a>)<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">)</span></a>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Notation</span> <a name="6f96854c58379fb78abd82e317c9a928"><span class="id" title="notation">&quot;</span></a>m &lt;=1 n" := (<a class="idref" href="IndPrinciples.html#le<sub>1</sub>"><span class="id" title="inductive">le<sub>1</sub></span></a> <span class="id" title="var">m</span> <span class="id" title="var">n</span>) (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 70).<br/>
</div>

<div class="doc">
此定义其实可以稍微简化一点，我们观察到左侧的参数 <span class="inlinecode"><span class="id" title="var">n</span></span>
    在定义中始终是相同的，于是可以把它变成整体定义中的一个“一般参数”，
    而非每个构造子的参数。
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <a name="le<sub>2</sub>"><span class="id" title="inductive">le<sub>2</sub></span></a> (<span class="id" title="var">n</span>:<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>) : <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;| <a name="le2_n"><span class="id" title="constructor">le2_n</span></a> : <a class="idref" href="IndPrinciples.html#le<sub>2</sub>"><span class="id" title="inductive">le<sub>2</sub></span></a> <a class="idref" href="IndPrinciples.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="IndPrinciples.html#n"><span class="id" title="variable">n</span></a><br/>
&nbsp;&nbsp;| <a name="le2_S"><span class="id" title="constructor">le2_S</span></a> <span class="id" title="var">m</span> (<span class="id" title="var">H</span> : <a class="idref" href="IndPrinciples.html#le<sub>2</sub>"><span class="id" title="inductive">le<sub>2</sub></span></a> <a class="idref" href="IndPrinciples.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="IndPrinciples.html#m"><span class="id" title="variable">m</span></a>) : <a class="idref" href="IndPrinciples.html#le<sub>2</sub>"><span class="id" title="inductive">le<sub>2</sub></span></a> <a class="idref" href="IndPrinciples.html#n"><span class="id" title="variable">n</span></a> (<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> <a class="idref" href="IndPrinciples.html#m"><span class="id" title="variable">m</span></a>).<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Notation</span> <a name="a01df31ff60b6b6672ad2ef549d28d<sub>65</sub>"><span class="id" title="notation">&quot;</span></a>m &lt;=2 n" := (<a class="idref" href="IndPrinciples.html#le<sub>2</sub>"><span class="id" title="inductive">le<sub>2</sub></span></a> <span class="id" title="var">m</span> <span class="id" title="var">n</span>) (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 70).<br/>
</div>

<div class="doc">
尽管第二个看起来不那么对称了，但它却更好一点。
    为什么呢？因为它会生成更简单的归纳法则。 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <a class="idref" href="IndPrinciples.html#le1_ind"><span class="id" title="definition">le1_ind</span></a>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;forall&nbsp;P&nbsp;:&nbsp;nat&nbsp;<span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span>&nbsp;nat&nbsp;<span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span>&nbsp;Prop,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(forall&nbsp;n&nbsp;:&nbsp;nat,&nbsp;P&nbsp;n&nbsp;n)&nbsp;<span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(forall&nbsp;n&nbsp;m&nbsp;:&nbsp;nat,&nbsp;n&nbsp;&lt;=1&nbsp;m&nbsp;<span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span>&nbsp;P&nbsp;n&nbsp;m&nbsp;<span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span>&nbsp;P&nbsp;n&nbsp;(S&nbsp;m))&nbsp;<span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;n&nbsp;n<sub>0</sub>&nbsp;:&nbsp;nat,&nbsp;n&nbsp;&lt;=1&nbsp;n<sub>0</sub>&nbsp;<span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span>&nbsp;P&nbsp;n&nbsp;n<sub>0</sub>&nbsp;*)</span><br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Check</span> <a class="idref" href="IndPrinciples.html#le2_ind"><span class="id" title="definition">le2_ind</span></a>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;&nbsp;forall&nbsp;(n&nbsp;:&nbsp;nat)&nbsp;(P&nbsp;:&nbsp;nat&nbsp;<span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span>&nbsp;Prop),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P&nbsp;n&nbsp;<span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(forall&nbsp;m&nbsp;:&nbsp;nat,&nbsp;n&nbsp;&lt;=2&nbsp;m&nbsp;<span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span>&nbsp;P&nbsp;m&nbsp;<span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span>&nbsp;P&nbsp;(S&nbsp;m))&nbsp;<span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;n<sub>0</sub>&nbsp;:&nbsp;nat,&nbsp;n&nbsp;&lt;=2&nbsp;n<sub>0</sub>&nbsp;<span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span>&nbsp;P&nbsp;n<sub>0</sub>&nbsp;*)</span><br/>
</div>

<div class="doc">
<a name="lab297"></a><h1 class="section">形式化 vs. 非形式化的归纳证明</h1>

<div class="paragraph"> </div>

 问：命题 <span class="inlinecode"><span class="id" title="var">P</span></span> 的形式化证明和同一个命题 <span class="inlinecode"><span class="id" title="var">P</span></span> 的非形式化证明之间是什么关系？

<div class="paragraph"> </div>

    答：后者应当<i>'教给'</i>读者如何产生前者。

<div class="paragraph"> </div>

    问：需要多少的细节？

<div class="paragraph"> </div>

    不幸的是，并没有一个正确的答案；当然了，其实有一系列的选择。

<div class="paragraph"> </div>

    一种选择是，我们可以为读者给出全部的形式化证明（也即，“非形式化的”证明只是把
    形式化的证明用文字表述出来）。这可能让读者有能力自己完成形式化的证明，但也许
    并没有<i>'教给'</i>读者什么东西。

<div class="paragraph"> </div>

  而另一种选择则是，我们可以说“某个定理为真，如果你觉得它有些困难那么可以自己尝试把它搞明白。”
  这也不是一种很好的教学策略，因为书写证明常常需要一两个对于要证明的东西的重要洞察，
  而多数读者往往在自己发现这些这些洞察前已经放弃了。

<div class="paragraph"> </div>

  一种中庸之道是——我们提供含有重要洞察的证明（免去读者像我们一开始一样辛苦地寻找证明），
  加上模式化部分的高层次建议（比如，归纳假设是什么，以及归纳证明中每个情形的证明责任），
  这样帮助读者节省自己重新构造这些东西的时间，但不会有过多的细节以至于主要的概念和想法受到干扰。

<div class="paragraph"> </div>

  我们在本章中已经仔细查看了形式化的归纳证明的“底层原理”，现在是时候来看看非形式化的归纳证明了。

<div class="paragraph"> </div>

  在现实世界的数学交流中，证明的书写既有冗长的，也有非常简洁的。
  尽管理想状态是二者中间的某种形式，但从有一点冗长的证明开始学习是有好处的。
  同时，在学习的过程中，有一个明确的标准来进行比较也是有益的。为此，
  我们提供了两份模板：一份用于归纳证明<i>'数据'</i>（也即，<span class="inlinecode"><span class="id" title="keyword">Type</span></span> 中我们进行归纳的东西），
  另一份用于归纳证明<i>'证据'</i>（也即，<span class="inlinecode"><span class="id" title="keyword">Prop</span></span> 中归纳定义的东西）。
<div class="paragraph"> </div>

<a name="lab298"></a><h2 class="section">对归纳定义的集合进行归纳</h2>

<div class="paragraph"> </div>

 <i>'模板'</i>：

<div class="paragraph"> </div>

<ul class="doclist">
<li> <i>'定理'</i>： &lt;有形如“For all <span class="inlinecode"><span class="id" title="var">n</span>:<span class="id" title="var">S</span></span>, <span class="inlinecode"><span class="id" title="var">P</span>(<span class="id" title="var">n</span>)</span>”的全称量化命题，其中 <span class="inlinecode"><span class="id" title="var">S</span></span>
          是某个归纳定义的集合。&gt;

<div class="paragraph"> </div>

         <i>'证明'</i>： 对 <span class="inlinecode"><span class="id" title="var">n</span></span> 进行归纳。

<div class="paragraph"> </div>

           &lt;<span class="inlinecode"><span class="id" title="var">S</span></span> 中的每个构造子 <span class="inlinecode"><span class="id" title="var">c</span></span> 的情形……&gt;

<div class="paragraph"> </div>

<ul class="doclist">
<li> 假设 <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">c</span></span> <span class="inlinecode"><span class="id" title="var">a<sub>1</sub></span></span> <span class="inlinecode">...</span> <span class="inlinecode"><span class="id" title="var">ak</span></span>，其中 &lt;…… 这里我们为每个具有类型 <span class="inlinecode"><span class="id" title="var">S</span></span> 的 <span class="inlinecode"><span class="id" title="var">a</span></span> 陈述其归纳假设（IH）&gt; 。
             我们需要证明 &lt;…… 我们在这里重新陈述 <span class="inlinecode"><span class="id" title="var">P</span>(<span class="id" title="var">c</span></span> <span class="inlinecode"><span class="id" title="var">a<sub>1</sub></span></span> <span class="inlinecode">...</span> <span class="inlinecode"><span class="id" title="var">ak</span>)</span>&gt;。

<div class="paragraph"> </div>

             &lt;继续并证明 <span class="inlinecode"><span class="id" title="var">P</span>(<span class="id" title="var">n</span>)</span> 来完成这个情形……&gt;

<div class="paragraph"> </div>


</li>
<li> &lt;其他情形以此类推……&gt;                        <font size=-2>&#9744;</font>

</li>
</ul>

</li>
</ul>

<div class="paragraph"> </div>

    <i>'举例'</i>:

<div class="paragraph"> </div>

<ul class="doclist">
<li> <i>'定理'</i>: 对所有集合 <span class="inlinecode"><span class="id" title="var">X</span></span>， 列表 <span class="inlinecode"><span class="id" title="var">l</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">X</span></span>，以及数字 <span class="inlinecode"><span class="id" title="var">n</span></span>，如果
          <span class="inlinecode"><span class="id" title="var">length</span></span> <span class="inlinecode"><span class="id" title="var">l</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">n</span></span> 那么 <span class="inlinecode"><span class="id" title="var">index</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n</span>)</span> <span class="inlinecode"><span class="id" title="var">l</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">None</span></span>。

<div class="paragraph"> </div>

        <i>'证明'</i>: 对 <span class="inlinecode"><span class="id" title="var">l</span></span> 进行归纳。

<div class="paragraph"> </div>

<ul class="doclist">
<li> 假设 <span class="inlinecode"><span class="id" title="var">l</span></span> <span class="inlinecode">=</span> <span class="inlinecode">[]</span>。我们需要证明，对于任意数字 <span class="inlinecode"><span class="id" title="var">n</span></span>，如果 <span class="inlinecode"><span class="id" title="var">length</span></span> <span class="inlinecode">[]</span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">n</span></span>，那么
         <span class="inlinecode"><span class="id" title="var">index</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n</span>)</span> <span class="inlinecode">[]</span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">None</span></span>。

<div class="paragraph"> </div>

          可从 <span class="inlinecode"><span class="id" title="var">index</span></span> 的定义中直接得出。

<div class="paragraph"> </div>


</li>
<li> 假设 <span class="inlinecode"><span class="id" title="var">l</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">::</span> <span class="inlinecode"><span class="id" title="var">l'</span></span> 对某个 <span class="inlinecode"><span class="id" title="var">x</span></span> 和 <span class="inlinecode"><span class="id" title="var">l'</span></span>，其中 <span class="inlinecode"><span class="id" title="var">length</span></span> <span class="inlinecode"><span class="id" title="var">l'</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">n'</span></span> 对任意数字 <span class="inlinecode"><span class="id" title="var">n'</span></span>
          蕴含了 <span class="inlinecode"><span class="id" title="var">index</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n'</span>)</span> <span class="inlinecode"><span class="id" title="var">l'</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">None</span></span>。我们需要证明，对任意数字 <span class="inlinecode"><span class="id" title="var">n</span></span>，如果
          <span class="inlinecode"><span class="id" title="var">length</span></span> <span class="inlinecode">(<span class="id" title="var">x</span>::<span class="id" title="var">l'</span>)</span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">n</span></span> 那么 <span class="inlinecode"><span class="id" title="var">index</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n</span>)</span> <span class="inlinecode">(<span class="id" title="var">x</span>::<span class="id" title="var">l'</span>)</span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">None</span></span>。

<div class="paragraph"> </div>

          设 <span class="inlinecode"><span class="id" title="var">n</span></span> 为数字且 <span class="inlinecode"><span class="id" title="var">length</span></span> <span class="inlinecode"><span class="id" title="var">l</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">n</span></span>。因为
<br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">length</span> <span class="id" title="var">l</span> = <span class="id" title="var">length</span> (<span class="id" title="var">x</span>::<span class="id" title="var">l'</span>) = <span class="id" title="var">S</span> (<span class="id" title="var">length</span> <span class="id" title="var">l'</span>),
<div class="paragraph"> </div>

</span>          需要证明
<br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">index</span> (<span class="id" title="var">S</span> (<span class="id" title="var">length</span> <span class="id" title="var">l'</span>)) <span class="id" title="var">l'</span> = <span class="id" title="var">None</span>.
<div class="paragraph"> </div>

</span>          若选取 <span class="inlinecode"><span class="id" title="var">n'</span></span> 为 <span class="inlinecode"><span class="id" title="var">length</span></span> <span class="inlinecode"><span class="id" title="var">l'</span></span> 这可从归纳假设中直接得出。  <font size=-2>&#9744;</font> 
</li>
</ul>

</li>
</ul>

<div class="paragraph"> </div>

<a name="lab299"></a><h2 class="section">对归纳定义的命题进行归纳</h2>

<div class="paragraph"> </div>

 由于归纳定义的证明对象经常被称作“导出树（derivation trees）”，这种形式的
    证明也被叫做<i>'在导出式上归纳'</i>。
    <i>'模板'</i>：

<div class="paragraph"> </div>

<ul class="doclist">
<li> <i>'定理'</i>: &lt;有形如“<span class="inlinecode"><span class="id" title="var">Q</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">P</span></span>”的命题，其中 <span class="inlinecode"><span class="id" title="var">Q</span></span> 是某个归纳定义的命题
        （更一般地，“对任意 <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode"><span class="id" title="var">y</span></span> <span class="inlinecode"><span class="id" title="var">z</span></span>，<span class="inlinecode"><span class="id" title="var">Q</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode"><span class="id" title="var">y</span></span> <span class="inlinecode"><span class="id" title="var">z</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode"><span class="id" title="var">y</span></span> <span class="inlinecode"><span class="id" title="var">z</span></span>”）&gt;

<div class="paragraph"> </div>

         <i>'证明'</i>: 对 <span class="inlinecode"><span class="id" title="var">Q</span></span> 的导出式进行归纳。&lt;或者，更一般地，“假设给定 <span class="inlinecode"><span class="id" title="var">x</span></span>，<span class="inlinecode"><span class="id" title="var">y</span></span> 和
         <span class="inlinecode"><span class="id" title="var">z</span></span>。通过对 <span class="inlinecode"><span class="id" title="var">Q</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode"><span class="id" title="var">y</span></span> <span class="inlinecode"><span class="id" title="var">z</span></span> 的导出式进行归纳，我们证明 <span class="inlinecode"><span class="id" title="var">Q</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode"><span class="id" title="var">y</span></span> <span class="inlinecode"><span class="id" title="var">z</span></span> 蕴含 <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode"><span class="id" title="var">y</span></span> <span class="inlinecode"><span class="id" title="var">z</span></span>”……&gt;

<div class="paragraph"> </div>

           &lt;<span class="inlinecode"><span class="id" title="var">Q</span></span> 中的每个构造子 <span class="inlinecode"><span class="id" title="var">c</span></span> 的情形……&gt;

<div class="paragraph"> </div>

<ul class="doclist">
<li> 假设被用于证明 <span class="inlinecode"><span class="id" title="var">Q</span></span> 的最终规则是 <span class="inlinecode"><span class="id" title="var">c</span></span>。那么&lt;……我们在这里陈述所有 <span class="inlinecode"><span class="id" title="var">a</span></span> 的类型，
            从构造子的定义中得到的任何等式，以及每个具有类型 <span class="inlinecode"><span class="id" title="var">Q</span></span> 的 <span class="inlinecode"><span class="id" title="var">a</span></span> 的归纳假设&gt;。
            我们需要证明&lt;……我们在这里重新陈述 <span class="inlinecode"><span class="id" title="var">P</span></span>&gt;。

<div class="paragraph"> </div>

             &lt;继续并证明 <span class="inlinecode"><span class="id" title="var">P</span></span> 来完成这个情形……&gt;

<div class="paragraph"> </div>


</li>
<li> &lt;其他情形以此类推……&gt;                        <font size=-2>&#9744;</font>

</li>
</ul>

</li>
</ul>

<div class="paragraph"> </div>

    <i>'举例'</i>

<ul class="doclist">
<li> <i>'定理'</i>: <span class="inlinecode">≤</span> 关系是传递的，也即，对任意数字 <span class="inlinecode"><span class="id" title="var">n</span></span>，<span class="inlinecode"><span class="id" title="var">m</span></span> 和 <span class="inlinecode"><span class="id" title="var">o</span></span>，如果
         <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">≤</span> <span class="inlinecode"><span class="id" title="var">m</span></span> 且 <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode">≤</span> <span class="inlinecode"><span class="id" title="var">o</span></span> 那么 <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">≤</span> <span class="inlinecode"><span class="id" title="var">o</span></span>。

<div class="paragraph"> </div>

         <i>'证明'</i>: 对 <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode">≤</span> <span class="inlinecode"><span class="id" title="var">o</span></span> 的导出式进行归纳。

<div class="paragraph"> </div>

<ul class="doclist">
<li> 假设被用于证明 <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode">≤</span> <span class="inlinecode"><span class="id" title="var">o</span></span> 的最终规则是 <span class="inlinecode"><span class="id" title="var">le_n</span></span>。
             那么 <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">o</span></span> 且我们需要证明 <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">≤</span> <span class="inlinecode"><span class="id" title="var">m</span></span>，其可从假设中直接得出。

<div class="paragraph"> </div>


</li>
<li> 假设被用于证明 <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode">≤</span> <span class="inlinecode"><span class="id" title="var">o</span></span> 的最终规则是 <span class="inlinecode"><span class="id" title="var">le_S</span></span>。
             那么 <span class="inlinecode"><span class="id" title="var">o</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">o'</span></span> 对某个 <span class="inlinecode"><span class="id" title="var">o'</span></span> 且 <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode">≤</span> <span class="inlinecode"><span class="id" title="var">o'</span></span>。我们需要证明 <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">≤</span> <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">o'</span></span>。
             由归纳假设得出，<span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">≤</span> <span class="inlinecode"><span class="id" title="var">o'</span></span>。

<div class="paragraph"> </div>

             因此，根据 <span class="inlinecode"><span class="id" title="var">le_S</span></span>，<span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">≤</span> <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">o'</span></span>。  <font size=-2>&#9744;</font> 
</li>
</ul>

</li>
</ul>

</div>

<div class="doc">
<a name="lab300"></a><h1 class="section">Explicit Proof Objects for Induction (Optional)</h1>

<div class="paragraph"> </div>

 Although tactic-based proofs are normally much easier to
    work with, the ability to write a proof term directly is sometimes
    very handy, particularly when we want Coq to do something slightly
    non-standard.  
<div class="paragraph"> </div>

 Recall again the induction principle on naturals that Coq generates for
    us automatically from the Inductive declation for <span class="inlinecode"><span class="id" title="var">nat</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#nat_ind"><span class="id" title="definition">nat_ind</span></a>.<br/>
<span class="comment">(*&nbsp;===&gt;<br/>
&nbsp;&nbsp;&nbsp;nat_ind&nbsp;:&nbsp;forall&nbsp;P&nbsp;:&nbsp;nat&nbsp;<span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span>&nbsp;Prop,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P&nbsp;0&nbsp;<span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(forall&nbsp;n&nbsp;:&nbsp;nat,&nbsp;P&nbsp;n&nbsp;<span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span>&nbsp;P&nbsp;(S&nbsp;n))&nbsp;<span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;n&nbsp;:&nbsp;nat,&nbsp;P&nbsp;n&nbsp;&nbsp;*)</span><br/>
</div>

<div class="doc">
There's nothing magic about this induction lemma: it's just
   another Coq lemma that requires a proof.  Coq generates the proof
   automatically too...  
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Print</span> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#nat_ind"><span class="id" title="definition">nat_ind</span></a>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;(after&nbsp;some&nbsp;slight&nbsp;tidying)<br/>
nat_ind&nbsp;:=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;fun&nbsp;(P&nbsp;:&nbsp;nat&nbsp;<span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span>&nbsp;Prop)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(f&nbsp;:&nbsp;P&nbsp;0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(f<sub>0</sub>&nbsp;:&nbsp;forall&nbsp;n&nbsp;:&nbsp;nat,&nbsp;P&nbsp;n&nbsp;<span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span>&nbsp;P&nbsp;(S&nbsp;n))&nbsp;=&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fix&nbsp;F&nbsp;(n&nbsp;:&nbsp;nat)&nbsp;:&nbsp;P&nbsp;n&nbsp;:=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;match&nbsp;n&nbsp;with<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;0&nbsp;=&gt;&nbsp;f<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;S&nbsp;n<sub>0</sub>&nbsp;=&gt;&nbsp;f<sub>0</sub>&nbsp;n<sub>0</sub>&nbsp;(F&nbsp;n<sub>0</sub>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end.<br/>
*)</span><br/>
</div>

<div class="doc">
We can read this as follows:
     Suppose we have evidence <span class="inlinecode"><span class="id" title="var">f</span></span> that <span class="inlinecode"><span class="id" title="var">P</span></span> holds on 0,  and
     evidence <span class="inlinecode"><span class="id" title="var">f<sub>0</sub></span></span> that <span class="inlinecode"><span class="id" title="keyword">∀</span></span> <span class="inlinecode"><span class="id" title="var">n</span>:<span class="id" title="var">nat</span>,</span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n</span>)</span>.
     Then we can prove that <span class="inlinecode"><span class="id" title="var">P</span></span> holds of an arbitrary nat <span class="inlinecode"><span class="id" title="var">n</span></span> via
     a recursive function <span class="inlinecode"><span class="id" title="var">F</span></span> (here defined using the expression
     form <span class="inlinecode"><span class="id" title="keyword">Fix</span></span> rather than by a top-level <span class="inlinecode"><span class="id" title="keyword">Fixpoint</span></span>
     declaration).  <span class="inlinecode"><span class="id" title="var">F</span></span> pattern matches on <span class="inlinecode"><span class="id" title="var">n</span></span>:
<ul class="doclist">
<li> If it finds 0, <span class="inlinecode"><span class="id" title="var">F</span></span> uses <span class="inlinecode"><span class="id" title="var">f</span></span> to show that <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> holds.

</li>
<li> If it finds <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n<sub>0</sub></span></span>, <span class="inlinecode"><span class="id" title="var">F</span></span> applies itself recursively on <span class="inlinecode"><span class="id" title="var">n<sub>0</sub></span></span>
         to obtain evidence that <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">n<sub>0</sub></span></span> holds; then it applies <span class="inlinecode"><span class="id" title="var">f<sub>0</sub></span></span>
         on that evidence to show that <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n</span>)</span> holds.

</li>
</ul>
    <span class="inlinecode"><span class="id" title="var">F</span></span> is just an ordinary recursive function that happens to
    operate on evidence in <span class="inlinecode"><span class="id" title="keyword">Prop</span></span> rather than on terms in <span class="inlinecode"><span class="id" title="keyword">Set</span></span>.

<div class="paragraph"> </div>


<div class="paragraph"> </div>

  We can adapt this approach to proving <span class="inlinecode"><span class="id" title="var">nat_ind</span></span> to help prove
    <i>non-standard</i> induction principles too.  As a motivating example,
    suppose that we want to prove the following lemma, directly
    relating the <span class="inlinecode"><span class="id" title="var">ev</span></span> predicate we defined in <a href="IndProp.html"><span class="inlineref">IndProp</span></a>
    to the <span class="inlinecode"><span class="id" title="var">evenb</span></span> function defined in <a href="Basics.html"><span class="inlineref">Basics</span></a>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <a name="evenb_ev"><span class="id" title="lemma">evenb_ev</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span>: <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>, <a class="idref" href="Basics.html#evenb"><span class="id" title="definition">evenb</span></a> <a class="idref" href="IndPrinciples.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="Basics.html#true"><span class="id" title="constructor">true</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="IndProp.html#ev"><span class="id" title="inductive">ev</span></a> <a class="idref" href="IndPrinciples.html#n"><span class="id" title="variable">n</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">n</span>; <span class="id" title="tactic">intros</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">apply</span> <a class="idref" href="IndProp.html#ev_0"><span class="id" title="constructor">ev_0</span></a>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">destruct</span> <span class="id" title="var">n</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">simpl</span> <span class="id" title="tactic">in</span> <span class="id" title="var">H</span>. <span class="id" title="tactic">inversion</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">simpl</span> <span class="id" title="tactic">in</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <a class="idref" href="IndProp.html#ev_SS"><span class="id" title="constructor">ev_SS</span></a>.<br/>
<span class="id" title="keyword">Abort</span>.<br/>
</div>

<div class="doc">
Attempts to prove this by standard induction on <span class="inlinecode"><span class="id" title="var">n</span></span> fail in the case for
    <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n</span>)</span>,  because the induction hypothesis only tells us something about
    <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span>, which is useless. There are various ways to hack around this problem;
    for example, we <i>can</i> use ordinary induction on <span class="inlinecode"><span class="id" title="var">n</span></span> to prove this (try it!):

<div class="paragraph"> </div>

    <span class="inlinecode"><span class="id" title="keyword">Lemma</span></span> <span class="inlinecode"><span class="id" title="var">evenb_ev'</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">∀</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span>,</span>
     <span class="inlinecode">(<span class="id" title="var">evenb</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">true</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">ev</span></span> <span class="inlinecode"><span class="id" title="var">n</span>)</span> <span class="inlinecode">∧</span> <span class="inlinecode">(<span class="id" title="var">evenb</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n</span>)</span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">true</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">ev</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n</span>))</span>.

<div class="paragraph"> </div>

    But we can make a much better proof by defining and proving a
    non-standard induction principle that goes "by twos":
 
</div>
<div class="code">

<br/>
&nbsp;<span class="id" title="keyword">Definition</span> <a name="nat_ind2"><span class="id" title="definition">nat_ind2</span></a> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">∀</span> (<span class="id" title="var">P</span> : <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <span class="id" title="keyword">Prop</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="IndPrinciples.html#P"><span class="id" title="variable">P</span></a> 0 <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="IndPrinciples.html#P"><span class="id" title="variable">P</span></a> 1 <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">(</span></a><span class="id" title="keyword">∀</span> <span class="id" title="var">n</span> : <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>, <a class="idref" href="IndPrinciples.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="IndPrinciples.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="IndPrinciples.html#P"><span class="id" title="variable">P</span></a> (<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a>(<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> <a class="idref" href="IndPrinciples.html#n"><span class="id" title="variable">n</span></a>))<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <span class="id" title="var">n</span> : <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> , <a class="idref" href="IndPrinciples.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="IndPrinciples.html#n"><span class="id" title="variable">n</span></a> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">fun</span> <span class="id" title="var">P</span> ⇒ <span class="id" title="keyword">fun</span> <span class="id" title="var">P<sub>0</sub></span> ⇒ <span class="id" title="keyword">fun</span> <span class="id" title="var">P<sub>1</sub></span> ⇒ <span class="id" title="keyword">fun</span> <span class="id" title="var">PSS</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">fix</span> <span class="id" title="var">f</span> (<span class="id" title="var">n</span>:<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>) := <span class="id" title="keyword">match</span> <a class="idref" href="IndPrinciples.html#n"><span class="id" title="variable">n</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0 ⇒ <a class="idref" href="IndPrinciples.html#P<sub>0</sub>"><span class="id" title="variable">P<sub>0</sub></span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 1 ⇒ <a class="idref" href="IndPrinciples.html#P<sub>1</sub>"><span class="id" title="variable">P<sub>1</sub></span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> (<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> <span class="id" title="var">n'</span>) ⇒ <a class="idref" href="IndPrinciples.html#PSS"><span class="id" title="variable">PSS</span></a> <span class="id" title="var">n'</span> (<a class="idref" href="IndPrinciples.html#f"><span class="id" title="variable">f</span></a> <span class="id" title="var">n'</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>
</div>

<div class="doc">
Once you get the hang of it, it is entirely straightforward to
     give an explicit proof term for induction principles like this.
     Proving this as a lemma using tactics is much less intuitive.

<div class="paragraph"> </div>

     The <span class="inlinecode"><span class="id" title="tactic">induction</span></span> <span class="inlinecode">...</span> <span class="inlinecode"><span class="id" title="keyword">using</span></span> tactic variant gives a convenient way to
     utilize a non-standard induction principle like this. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <a name="evenb_ev"><span class="id" title="lemma">evenb_ev</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span>, <a class="idref" href="Basics.html#evenb"><span class="id" title="definition">evenb</span></a> <a class="idref" href="IndPrinciples.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="Basics.html#true"><span class="id" title="constructor">true</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="IndProp.html#ev"><span class="id" title="inductive">ev</span></a> <a class="idref" href="IndPrinciples.html#n"><span class="id" title="variable">n</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;<span class="id" title="tactic">intros</span>.<br/>
&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">n</span> <span class="id" title="keyword">as</span> [ | |<span class="id" title="var">n'</span>] <span class="id" title="keyword">using</span> <a class="idref" href="IndPrinciples.html#nat_ind2"><span class="id" title="definition">nat_ind2</span></a>.<br/>
&nbsp;- <span class="id" title="tactic">apply</span> <a class="idref" href="IndProp.html#ev_0"><span class="id" title="constructor">ev_0</span></a>.<br/>
&nbsp;- <span class="id" title="tactic">simpl</span> <span class="id" title="tactic">in</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">inversion</span> <span class="id" title="var">H</span>.<br/>
&nbsp;- <span class="id" title="tactic">simpl</span> <span class="id" title="tactic">in</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <a class="idref" href="IndProp.html#ev_SS"><span class="id" title="constructor">ev_SS</span></a>.<br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">IHn'</span>.<br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">H</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<a name="lab301"></a><h1 class="section">The Coq Trusted Computing Base</h1>

<div class="paragraph"> </div>

 One issue that arises with any automated proof assistant is "why
    trust it?": what if there is a bug in the implementation that
    renders all its reasoning suspect?

<div class="paragraph"> </div>

    While it is impossible to allay such concerns completely, the fact
    that Coq is based on the Curry-Howard correspondence gives it a
    strong foundation. Because propositions are just types and proofs
    are just terms, checking that an alleged proof of a proposition is
    valid just amounts to <i>type-checking</i> the term.  Type checkers are
    relatively small and straightforward programs, so the "trusted
    computing base" for Coq -- the part of the code that we have to
    believe is operating correctly -- is small too.

<div class="paragraph"> </div>

    What must a typechecker do?  Its primary job is to make sure that
    in each function application the expected and actual argument
    types match, that the arms of a <span class="inlinecode"><span class="id" title="keyword">match</span></span> expression are constructor
    patterns belonging to the inductive type being matched over and
    all arms of the <span class="inlinecode"><span class="id" title="keyword">match</span></span> return the same type, and so on.

<div class="paragraph"> </div>

    There are a few additional wrinkles:

<div class="paragraph"> </div>

<ul class="doclist">
<li> Since Coq types can themselves be expressions, the checker must
      normalize these (by using the computation rules) before
      comparing them.

<div class="paragraph"> </div>


</li>
<li> The checker must make sure that <span class="inlinecode"><span class="id" title="keyword">match</span></span> expressions are
      <i>exhaustive</i>.  That is, there must be an arm for every possible
      constructor.  To see why, consider the following alleged proof
      object:
<br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <span class="id" title="var">or_bogus</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span>, <span class="id" title="var">P</span> ∨ <span class="id" title="var">Q</span> → <span class="id" title="var">P</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">fun</span> (<span class="id" title="var">P</span> <span class="id" title="var">Q</span> : <span class="id" title="keyword">Prop</span>) (<span class="id" title="var">A</span> : <span class="id" title="var">P</span> ∨ <span class="id" title="var">Q</span>) ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">A</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">or_introl</span> <span class="id" title="var">H</span> ⇒ <span class="id" title="var">H</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.
<div class="paragraph"> </div>

</span>      All the types here match correctly, but the <span class="inlinecode"><span class="id" title="keyword">match</span></span> only
      considers one of the possible constructors for <span class="inlinecode"><span class="id" title="var">or</span></span>.  Coq's
      exhaustiveness check will reject this definition.

<div class="paragraph"> </div>


</li>
<li> The checker must make sure that each <span class="inlinecode"><span class="id" title="keyword">fix</span></span> expression
      terminates.  It does this using a syntactic check to make sure
      that each recursive call is on a subexpression of the original
      argument.  To see why this is essential, consider this alleged
      proof:
<br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <span class="id" title="var">nat_false</span> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">n</span>:<span class="id" title="var">nat</span>), <span class="id" title="var">False</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">fix</span> <span class="id" title="var">f</span> (<span class="id" title="var">n</span>:<span class="id" title="var">nat</span>) : <span class="id" title="var">False</span> := <span class="id" title="var">f</span> <span class="id" title="var">n</span>.
<div class="paragraph"> </div>

</span>      Again, this is perfectly well-typed, but (fortunately) Coq will
      reject it. 
</li>
</ul>

<div class="paragraph"> </div>

 Note that the soundness of Coq depends only on the correctness of
    this typechecking engine, not on the tactic machinery.  If there
    is a bug in a tactic implementation (and this certainly does
    happen!), that tactic might construct an invalid proof term.  But
    when you type <span class="inlinecode"><span class="id" title="keyword">Qed</span></span>, Coq checks the term for validity from
    scratch.  Only lemmas whose proofs pass the type-checker can be
    used in further proof developments.  
</div>
<div class="code">

<br/>
<span class="comment">(*&nbsp;2022-03-14&nbsp;05:26:58&nbsp;(UTC+00)&nbsp;*)</span><br/>
</div>
</div>

<div id="footer">
<hr/><a href="coqindex.html">Index</a><hr/>This page has been generated by <a href="http://coq.inria.fr/">coqdoc</a>
</div>

</div>

</body>
</html>
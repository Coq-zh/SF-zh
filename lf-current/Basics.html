<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link href="common/css/sf.css" rel="stylesheet" type="text/css" />
<title>Basics: Coq 函数式编程</title>
<link href="common/jquery-ui/jquery-ui.css" rel="stylesheet">
<script src="common/jquery-ui/external/jquery/jquery.js"></script>
<script src="common/jquery-ui/jquery-ui.js"></script>
<script src="common/toggleproofs.js"></script>
<link href="common/css/lf.css" rel="stylesheet" type="text/css"/>
</head>

<body>

<div id="page">

<div id="header">
<div id='logoinheader'><a href='https://coq-zh.github.io/SF-zh/'>
<img src='common/media/image/sf_logo_sm.png' alt='Software Foundations Logo'></a></div>
<div class='booktitleinheader'><a href='index.html'>Volume 1: 逻辑基础</a></div>
<ul id='menu'>
   <li class='section_name'><a href='toc.html'>目录</a></li>
   <li class='section_name'><a href='coqindex.html'>索引</a></li>
   <li class='section_name'><a href='deps.html'>路线</a></li>
</ul>
</div>

<div id="main">

<h1 class="libtitle">Basics<span class="subtitle">Coq 函数式编程</span></h1>

<div class="code">
</div>


<div class="doc">
<a name="lab19"></a><h1 class="section">引言</h1>

<div class="paragraph"> </div>

 函数式编程风格建立在简单的、日常的数学直觉之上：若一个过程或方法没有副作用，
    那么在忽略效率的前提下，我们需要理解的一切便只剩下它如何将输入映射到输出了
    —— 也就是说，我们只需将它视作一种计算数学函数的具体方法即可。这也是
    “函数式编程”中“函数式”一词的含义之一。程序与简单数学对象之间这种直接的联系，
    同时支撑了对程序行为进行形式化证明的正确性以及非形式化论证的可靠性。

<div class="paragraph"> </div>

    函数式编程中“函数式”一词的另一个含义是它强调把函数作为<i>'一等'</i>的值
    —— 这类值可以作为参数传递给其它函数，可以作为结果返回，
    也可以包含在数据结构中等等。这种将函数当做数据的方式，
    产生了大量强大而有用的编程习语（Idiom）。

<div class="paragraph"> </div>

    其它常见的函数式语言特性包括能让构造和处理丰富数据结构更加简单的
    <i>'代数数据类型（Algebraic Data Type）'</i>和<i>'模式匹配（Pattern Matching）'</i>，
    以及用来支持抽象和代码复用的<i>'多态类型系统（Polymorphic Type System）'</i>。
    Coq 提供了所有这些特性。

<div class="paragraph"> </div>

    本章的前半部分介绍了 Coq 原生的函数式编程语言 <i>'Gallina'</i> 中最基本的元素，
    后半部分则介绍了一些基本<i>'策略（Tactic）'</i>，它可用于证明 Gallina 程序的简单性质。 
</div>

<div class="doc">
<a name="lab20"></a><h1 class="section">数据与函数</h1>

<div class="paragraph"> </div>

<a name="lab21"></a><h2 class="section">枚举类型</h2>

<div class="paragraph"> </div>

 Coq 的一个不同寻常之处在于它<i>'极小'</i>的内建特性集合。
    比如，Coq 并未提供通常的原语（atomic）类型（如布尔、整数、字符串等），
    而是提供了一种极为强大的，可以从头定义新的数据类型的机制
    —— 上面所有常见的类型都是由它定义而产生的实例。

<div class="paragraph"> </div>

    当然，Coq 发行版同时也提供了内容丰富的标准库，其中定义了布尔值、
    数值，以及如列表、散列表等许多通用的数据结构。
    不过这些库中的定义并没有任何神秘之处，也没有原语（Primitive）的特点。
    为了说明这一点，我们并未在本课程中直接使用标准库中的数据类型，
    而是在整个教程中重新定义了其中的绝大部分。 
</div>

<div class="doc">
<a name="lab22"></a><h2 class="section">一周七日</h2>

<div class="paragraph"> </div>

 让我们从一个非常简单的例子开始，看看这种定义机制是如何工作的。
    以下声明会告诉 Coq 我们定义了一个数据集合，即一个<i>'类型（Type）'</i>。 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <a name="day"><span class="id" title="inductive">day</span></a> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;| <a name="monday"><span class="id" title="constructor">monday</span></a><br/>
&nbsp;&nbsp;| <a name="tuesday"><span class="id" title="constructor">tuesday</span></a><br/>
&nbsp;&nbsp;| <a name="wednesday"><span class="id" title="constructor">wednesday</span></a><br/>
&nbsp;&nbsp;| <a name="thursday"><span class="id" title="constructor">thursday</span></a><br/>
&nbsp;&nbsp;| <a name="friday"><span class="id" title="constructor">friday</span></a><br/>
&nbsp;&nbsp;| <a name="saturday"><span class="id" title="constructor">saturday</span></a><br/>
&nbsp;&nbsp;| <a name="sunday"><span class="id" title="constructor">sunday</span></a>.<br/>
</div>

<div class="doc">
这个新的类型名为 <span class="inlinecode"><span class="id" title="var">day</span></span>，成员包括 <span class="inlinecode"><span class="id" title="var">monday</span></span>、<span class="inlinecode"><span class="id" title="var">tuesday</span></span> 等等。

<div class="paragraph"> </div>

    定义了 <span class="inlinecode"><span class="id" title="var">day</span></span> 之后, 我们就能写一些操作星期的函数了。 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <a name="next_weekday"><span class="id" title="definition">next_weekday</span></a> (<span class="id" title="var">d</span>:<a class="idref" href="Basics.html#day"><span class="id" title="inductive">day</span></a>) : <a class="idref" href="Basics.html#day"><span class="id" title="inductive">day</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Basics.html#d"><span class="id" title="variable">d</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| <a class="idref" href="Basics.html#monday"><span class="id" title="constructor">monday</span></a>    ⇒ <a class="idref" href="Basics.html#tuesday"><span class="id" title="constructor">tuesday</span></a><br/>
&nbsp;&nbsp;| <a class="idref" href="Basics.html#tuesday"><span class="id" title="constructor">tuesday</span></a>   ⇒ <a class="idref" href="Basics.html#wednesday"><span class="id" title="constructor">wednesday</span></a><br/>
&nbsp;&nbsp;| <a class="idref" href="Basics.html#wednesday"><span class="id" title="constructor">wednesday</span></a> ⇒ <a class="idref" href="Basics.html#thursday"><span class="id" title="constructor">thursday</span></a><br/>
&nbsp;&nbsp;| <a class="idref" href="Basics.html#thursday"><span class="id" title="constructor">thursday</span></a>  ⇒ <a class="idref" href="Basics.html#friday"><span class="id" title="constructor">friday</span></a><br/>
&nbsp;&nbsp;| <a class="idref" href="Basics.html#friday"><span class="id" title="constructor">friday</span></a>    ⇒ <a class="idref" href="Basics.html#monday"><span class="id" title="constructor">monday</span></a><br/>
&nbsp;&nbsp;| <a class="idref" href="Basics.html#saturday"><span class="id" title="constructor">saturday</span></a>  ⇒ <a class="idref" href="Basics.html#monday"><span class="id" title="constructor">monday</span></a><br/>
&nbsp;&nbsp;| <a class="idref" href="Basics.html#sunday"><span class="id" title="constructor">sunday</span></a>    ⇒ <a class="idref" href="Basics.html#monday"><span class="id" title="constructor">monday</span></a><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>
</div>

<div class="doc">
注意，这里显式声明了函数的参数和返回类型。
    和大多数函数式编程语言一样，如果没有显式指定类型，Coq 通常会自己通过
    <i>'类型推断（Type Inference）'</i> 得出。不过我们会标上类型使其更加易读。 
<div class="paragraph"> </div>

 定义了函数之后，我们接下来应该用一些例子来检验它。
    实际上，在 Coq 中，一共有三种不同的检验方式：第一，我们可以用 <span class="inlinecode"><span class="id" title="keyword">Compute</span></span>
    指令来计算包含 <span class="inlinecode"><span class="id" title="var">next_weekday</span></span> 的复合表达式： 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Compute</span> (<a class="idref" href="Basics.html#next_weekday"><span class="id" title="definition">next_weekday</span></a> <a class="idref" href="Basics.html#friday"><span class="id" title="constructor">friday</span></a>).<br/>
<span class="comment">(*&nbsp;==&gt;&nbsp;monday&nbsp;:&nbsp;day&nbsp;*)</span><br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Compute</span> (<a class="idref" href="Basics.html#next_weekday"><span class="id" title="definition">next_weekday</span></a> (<a class="idref" href="Basics.html#next_weekday"><span class="id" title="definition">next_weekday</span></a> <a class="idref" href="Basics.html#saturday"><span class="id" title="constructor">saturday</span></a>)).<br/>
<span class="comment">(*&nbsp;==&gt;&nbsp;tuesday&nbsp;:&nbsp;day&nbsp;*)</span><br/>
</div>

<div class="doc">
（我们在注释中写出 Coq 返回的结果。如果你身边就有电脑，
    不妨自己用 Coq 解释器试一试：选一个你喜欢的 IDE，CoqIde 或
    Proof General 都可以。然后从本书附带的 Coq 源码中载入 <span class="inlinecode"><span class="id" title="var">Basics.v</span></span>
    文件，找到上面的例子，提交给 Coq，然后查看结果。） 
<div class="paragraph"> </div>

 第二，我们可以将<i>'期望'</i>的结果写成 Coq 的示例： 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Example</span> <a name="test_next_weekday"><span class="id" title="definition">test_next_weekday</span></a>:<br/>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">(</span></a><a class="idref" href="Basics.html#next_weekday"><span class="id" title="definition">next_weekday</span></a> (<a class="idref" href="Basics.html#next_weekday"><span class="id" title="definition">next_weekday</span></a> <a class="idref" href="Basics.html#saturday"><span class="id" title="constructor">saturday</span></a>)<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="Basics.html#tuesday"><span class="id" title="constructor">tuesday</span></a>.<br/>
</div>

<div class="doc">
该声明做了两件事：首先它断言 <span class="inlinecode"><span class="id" title="var">saturday</span></span> 之后的第二个工作日是
    <span class="inlinecode"><span class="id" title="var">tuesday</span></span>；然后它为该断言取了名字以便之后引用它。
    定义好断言后，我们还可以让 Coq 来验证它，就像这样： 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
具体细节目前并不重要，不过这段代码基本上可以读作
    “若等式两边的求值结果相同，该断言即可得证。”

<div class="paragraph"> </div>

    第三，我们可以让 Coq 从 <span class="inlinecode"><span class="id" title="keyword">Definition</span></span> 中<i>'提取（Extract）'</i>
    出用其它更加常规的编程语言编写的程序
    （如 OCaml、Scheme、Haskell 等），它们拥有高性能的编译器。
    这种能力非常有用，我们可以通过它将 Gallina 编写的 <i>'证明正确'</i>
    的算法转译成高效的机器码。（诚然，我们必须信任 OCaml/Haskell/Scheme
    的编译器，以及 Coq 提取工具自身的正确性，然而比起现在大多数软件的开发方式，
    这也是很大的进步了。）实际上，这就是 Coq 最主要的使用方式之一。
    在之后的章节中我们会回到这一主题上来。 
</div>

<div class="doc">
<a name="lab23"></a><h2 class="section">作业提交指南</h2>

<div class="paragraph"> </div>

 如果你在课堂中使用《软件基础》，你的讲师可能会用自动化脚本来为你的作业评分。
    为了让这些脚本能够正常工作（这样你才能拿到全部学分！），请认真遵循以下规则：
<ul class="doclist">
<li> 评分脚本在提取你提交的 <span class="inlinecode">.<span class="id" title="var">v</span></span> 文件时会用到其中的特殊标记。因此请勿修改练习的
        “分隔标记”，如练习的标题、名称、以及末尾的 <span class="inlinecode">[]</span> 等等。

</li>
<li> 不要删除练习。如果你想要跳过某个练习（例如它标记为“可选”或你无法解决它），
        可以在 <span class="inlinecode">.<span class="id" title="var">v</span></span> 文件中留下部分证明，这没关系，不过此时请确认它以 <span class="inlinecode"><span class="id" title="var">Admitted</span></span>
        结尾（不要用 <span class="inlinecode"><span class="id" title="keyword">Abort</span></span> 之类的东西）。

</li>
<li> 你也可以在解答中使用附加定义（如辅助函数，需要的引理等）。
        你可以将它们放在练习的头部和你要证明的定理之间。

</li>
<li> 如果你为了证明某定理而需要引入一个额外引理，且未能证明该引理，
        请确保该引理与使用它的原定理都以 <span class="inlinecode"><span class="id" title="var">Admitted</span></span> 而非 <span class="inlinecode"><span class="id" title="keyword">Qed</span></span> 结尾。
        这样能使在你利用原定理解决其他练习时得到部分分数。

</li>
</ul>

<div class="paragraph"> </div>

    你或许注意到每一章都附带有一个<i>'测试脚本'</i>来自动计算该章节已完成
    的作业的分数。这些脚本一般只作为自动评分工具，但你也可以用它们在提交前
    再一次确认作业格式的正确性。
    你可以在一个终端窗口中输入 "<span class="inlinecode"><span class="id" title="var">make</span></span> <span class="inlinecode"><span class="id" title="var">BasicsTest.vo</span></span>" 或下面的命令来运行这些
    测试脚本
<br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">coqc</span> -<span class="id" title="var">Q</span> . <span class="id" title="var">LF</span> <span class="id" title="var">Basics.v</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">coqc</span> -<span class="id" title="var">Q</span> . <span class="id" title="var">LF</span> <span class="id" title="var">BasicsTest.v</span>
<div class="paragraph"> </div>

</span>    你并不需要提交 <span class="inlinecode"><span class="id" title="var">BasicsTest.v</span></span> 这种测试脚本（也不需要提交前言 <span class="inlinecode"><span class="id" title="var">Preface.v</span></span>）。

<div class="paragraph"> </div>

    如果你的班级使用 Canvas 系统来提交作业。
<ul class="doclist">
<li> 如果你提交了多个不同版本的作业，你可能会注意到它们在系统中有着
        不同的名字。这是正常情况，只有最新的提交会被评分。

</li>
<li> 如果你需要同时提交多个文件（例如一次作业中包含多个不同的章节），
        你需要创建一个一次性包含所有文件的提交。
       （译者注：关于多文件提交细节请查看英文原文。）
        To hand in multiple files at the same time (if more than one
        chapter is assigned in the same week), you need to make a
        single submission with all the files at once using the button
        "Add another file" just above the comment box. 
</li>
</ul>

<div class="paragraph"> </div>

 The <span class="inlinecode"><span class="id" title="keyword">Require</span></span> <span class="inlinecode"><span class="id" title="keyword">Export</span></span> statement on the next line tells Coq to use
    the <span class="inlinecode"><span class="id" title="var">String</span></span> module from the standard library.  We'll use strings
    ourselves in later chapters, but we need to <span class="inlinecode"><span class="id" title="keyword">Require</span></span> it here so
    that the grading scripts can use it for internal purposes. 
</div>
<div class="code">
<span class="id" title="var">From</span> <span class="id" title="var">Coq</span> <span class="id" title="keyword">Require</span> <span class="id" title="keyword">Export</span> <a class="idref" href="http://coq.inria.fr/library//Coq.Strings.String.html#"><span class="id" title="library">String</span></a>.<br/>
</div>

<div class="doc">
<a name="lab24"></a><h2 class="section">布尔值</h2>

<div class="paragraph"> </div>

 通过类似的方式，我们可以为布尔值定义常见的 <span class="inlinecode"><span class="id" title="var">bool</span></span> 类型，它包括
    <span class="inlinecode"><span class="id" title="var">true</span></span> 和 <span class="inlinecode"><span class="id" title="var">false</span></span> 两个成员。 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <a name="bool"><span class="id" title="inductive">bool</span></a> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;| <a name="true"><span class="id" title="constructor">true</span></a><br/>
&nbsp;&nbsp;| <a name="false"><span class="id" title="constructor">false</span></a>.<br/>
</div>

<div class="doc">
布尔值的函数可按照同样的方式来定义： 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <a name="negb"><span class="id" title="definition">negb</span></a> (<span class="id" title="var">b</span>:<a class="idref" href="Basics.html#bool"><span class="id" title="inductive">bool</span></a>) : <a class="idref" href="Basics.html#bool"><span class="id" title="inductive">bool</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Basics.html#b"><span class="id" title="variable">b</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| <a class="idref" href="Basics.html#true"><span class="id" title="constructor">true</span></a> ⇒ <a class="idref" href="Basics.html#false"><span class="id" title="constructor">false</span></a><br/>
&nbsp;&nbsp;| <a class="idref" href="Basics.html#false"><span class="id" title="constructor">false</span></a> ⇒ <a class="idref" href="Basics.html#true"><span class="id" title="constructor">true</span></a><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Definition</span> <a name="andb"><span class="id" title="definition">andb</span></a> (<span class="id" title="var">b<sub>1</sub></span>:<a class="idref" href="Basics.html#bool"><span class="id" title="inductive">bool</span></a>) (<span class="id" title="var">b<sub>2</sub></span>:<a class="idref" href="Basics.html#bool"><span class="id" title="inductive">bool</span></a>) : <a class="idref" href="Basics.html#bool"><span class="id" title="inductive">bool</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Basics.html#b<sub>1</sub>"><span class="id" title="variable">b<sub>1</sub></span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| <a class="idref" href="Basics.html#true"><span class="id" title="constructor">true</span></a> ⇒ <a class="idref" href="Basics.html#b<sub>2</sub>"><span class="id" title="variable">b<sub>2</sub></span></a><br/>
&nbsp;&nbsp;| <a class="idref" href="Basics.html#false"><span class="id" title="constructor">false</span></a> ⇒ <a class="idref" href="Basics.html#false"><span class="id" title="constructor">false</span></a><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Definition</span> <a name="orb"><span class="id" title="definition">orb</span></a> (<span class="id" title="var">b<sub>1</sub></span>:<a class="idref" href="Basics.html#bool"><span class="id" title="inductive">bool</span></a>) (<span class="id" title="var">b<sub>2</sub></span>:<a class="idref" href="Basics.html#bool"><span class="id" title="inductive">bool</span></a>) : <a class="idref" href="Basics.html#bool"><span class="id" title="inductive">bool</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Basics.html#b<sub>1</sub>"><span class="id" title="variable">b<sub>1</sub></span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| <a class="idref" href="Basics.html#true"><span class="id" title="constructor">true</span></a> ⇒ <a class="idref" href="Basics.html#true"><span class="id" title="constructor">true</span></a><br/>
&nbsp;&nbsp;| <a class="idref" href="Basics.html#false"><span class="id" title="constructor">false</span></a> ⇒ <a class="idref" href="Basics.html#b<sub>2</sub>"><span class="id" title="variable">b<sub>2</sub></span></a><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>
</div>

<div class="doc">
（虽然我们正尝试从零开始定义布尔类型，
    但由于 Coq 的标准库中也提供了布尔类型的默认实现，以及大量有用的函数和引理。
    我们会尽量让自己的定义和定理的名字与标准库保持一致。） 
<div class="paragraph"> </div>

 其中 <span class="inlinecode"><span class="id" title="var">andb</span></span> 和 <span class="inlinecode"><span class="id" title="var">orb</span></span> 演示了如何定义多参函数。
    以下四个“单元测试”则演示了如何应用这些函数，
    它们构成了 <span class="inlinecode"><span class="id" title="var">orb</span></span> 函数的完整规范（Specification），即真值表： 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Example</span> <a name="test_orb1"><span class="id" title="definition">test_orb1</span></a>:  <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">(</span></a><a class="idref" href="Basics.html#orb"><span class="id" title="definition">orb</span></a> <a class="idref" href="Basics.html#true"><span class="id" title="constructor">true</span></a>  <a class="idref" href="Basics.html#false"><span class="id" title="constructor">false</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="Basics.html#true"><span class="id" title="constructor">true</span></a>.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>
<span class="id" title="keyword">Example</span> <a name="test_orb2"><span class="id" title="definition">test_orb2</span></a>:  <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">(</span></a><a class="idref" href="Basics.html#orb"><span class="id" title="definition">orb</span></a> <a class="idref" href="Basics.html#false"><span class="id" title="constructor">false</span></a> <a class="idref" href="Basics.html#false"><span class="id" title="constructor">false</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="Basics.html#false"><span class="id" title="constructor">false</span></a>.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>
<span class="id" title="keyword">Example</span> <a name="test_orb3"><span class="id" title="definition">test_orb3</span></a>:  <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">(</span></a><a class="idref" href="Basics.html#orb"><span class="id" title="definition">orb</span></a> <a class="idref" href="Basics.html#false"><span class="id" title="constructor">false</span></a> <a class="idref" href="Basics.html#true"><span class="id" title="constructor">true</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">)</span></a>  <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="Basics.html#true"><span class="id" title="constructor">true</span></a>.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>
<span class="id" title="keyword">Example</span> <a name="test_orb4"><span class="id" title="definition">test_orb4</span></a>:  <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">(</span></a><a class="idref" href="Basics.html#orb"><span class="id" title="definition">orb</span></a> <a class="idref" href="Basics.html#true"><span class="id" title="constructor">true</span></a>  <a class="idref" href="Basics.html#true"><span class="id" title="constructor">true</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">)</span></a>  <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="Basics.html#true"><span class="id" title="constructor">true</span></a>.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
我们也可以为刚定义的布尔运算引入更加熟悉的中缀语法。
    <span class="inlinecode"><span class="id" title="keyword">Notation</span></span> 指令能为既有的定义赋予新的符号记法。 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Notation</span> <a name="5337a72ca9eeeb81296bec4669839306"><span class="id" title="notation">&quot;</span></a>x &amp;&amp; y" := (<a class="idref" href="Basics.html#andb"><span class="id" title="definition">andb</span></a> <span class="id" title="var">x</span> <span class="id" title="var">y</span>).<br/>
<span class="id" title="keyword">Notation</span> <a name="7d9f7c827b426ef974af6039f1332d<sub>14</sub>"><span class="id" title="notation">&quot;</span></a>x || y" := (<a class="idref" href="Basics.html#orb"><span class="id" title="definition">orb</span></a> <span class="id" title="var">x</span> <span class="id" title="var">y</span>).<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Example</span> <a name="test_orb5"><span class="id" title="definition">test_orb5</span></a>:  <a class="idref" href="Basics.html#false"><span class="id" title="constructor">false</span></a> <a class="idref" href="Basics.html#7d9f7c827b426ef974af6039f1332d<sub>14</sub>"><span class="id" title="notation">||</span></a> <a class="idref" href="Basics.html#false"><span class="id" title="constructor">false</span></a> <a class="idref" href="Basics.html#7d9f7c827b426ef974af6039f1332d<sub>14</sub>"><span class="id" title="notation">||</span></a> <a class="idref" href="Basics.html#true"><span class="id" title="constructor">true</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="Basics.html#true"><span class="id" title="constructor">true</span></a>.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<i>'关于记法的说明'</i>：在 <span class="inlinecode">.<span class="id" title="var">v</span></span> 文件中，我们用方括号来界定注释中的
    Coq 代码片段；这种约定也在 <span class="inlinecode"><span class="id" title="var">coqdoc</span></span> 文档工具中使用，
    它能让代码与周围的文本从视觉上区分开来。
    在 HTML 版的文件中，这部分文本会以<i>'不同的字体'</i>显示。 
<div class="paragraph"> </div>

 下面的例子展示了 Coq 的另一个特性: 条件表达式... 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <a name="negb'"><span class="id" title="definition">negb'</span></a> (<span class="id" title="var">b</span>:<a class="idref" href="Basics.html#bool"><span class="id" title="inductive">bool</span></a>) : <a class="idref" href="Basics.html#bool"><span class="id" title="inductive">bool</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">if</span> <a class="idref" href="Basics.html#b"><span class="id" title="variable">b</span></a> <span class="id" title="keyword">then</span> <a class="idref" href="Basics.html#false"><span class="id" title="constructor">false</span></a><br/>
&nbsp;&nbsp;<span class="id" title="keyword">else</span> <a class="idref" href="Basics.html#true"><span class="id" title="constructor">true</span></a>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Definition</span> <a name="andb'"><span class="id" title="definition">andb'</span></a> (<span class="id" title="var">b<sub>1</sub></span>:<a class="idref" href="Basics.html#bool"><span class="id" title="inductive">bool</span></a>) (<span class="id" title="var">b<sub>2</sub></span>:<a class="idref" href="Basics.html#bool"><span class="id" title="inductive">bool</span></a>) : <a class="idref" href="Basics.html#bool"><span class="id" title="inductive">bool</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">if</span> <a class="idref" href="Basics.html#b<sub>1</sub>"><span class="id" title="variable">b<sub>1</sub></span></a> <span class="id" title="keyword">then</span> <a class="idref" href="Basics.html#b<sub>2</sub>"><span class="id" title="variable">b<sub>2</sub></span></a><br/>
&nbsp;&nbsp;<span class="id" title="keyword">else</span> <a class="idref" href="Basics.html#false"><span class="id" title="constructor">false</span></a>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Definition</span> <a name="orb'"><span class="id" title="definition">orb'</span></a> (<span class="id" title="var">b<sub>1</sub></span>:<a class="idref" href="Basics.html#bool"><span class="id" title="inductive">bool</span></a>) (<span class="id" title="var">b<sub>2</sub></span>:<a class="idref" href="Basics.html#bool"><span class="id" title="inductive">bool</span></a>) : <a class="idref" href="Basics.html#bool"><span class="id" title="inductive">bool</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">if</span> <a class="idref" href="Basics.html#b<sub>1</sub>"><span class="id" title="variable">b<sub>1</sub></span></a> <span class="id" title="keyword">then</span> <a class="idref" href="Basics.html#true"><span class="id" title="constructor">true</span></a><br/>
&nbsp;&nbsp;<span class="id" title="keyword">else</span> <a class="idref" href="Basics.html#b<sub>2</sub>"><span class="id" title="variable">b<sub>2</sub></span></a>.<br/>
</div>

<div class="doc">
Coq 的条件表达式相较于其他语言的，只有一点小小的扩展。由于 <span class="inlinecode"><span class="id" title="var">bool</span></span> 类型
    并不是内建类型，Coq 实际上支持对_任何_归纳定义的双子句表达式使用 "if" 表达式
   （不过恰巧在这里该表达式被称为 <span class="inlinecode"><span class="id" title="var">bool</span></span>）。当条件求值后得到的是第一个
    子句的 “构造子” (constructor)，那么条件就会被认为是 “真” <span class="inlinecode"><span class="id" title="var">true</span></span>（不过恰巧
    在这里第一个分支的构造子被称为 “真” <span class="inlinecode"><span class="id" title="var">true</span></span>，并且如果求值后得到的是第二个子句，
    那么条件就被认为是 “假” <span class="inlinecode"><span class="id" title="var">false</span></span>）。 
<div class="paragraph"> </div>

<a name="lab25"></a><h4 class="section">练习：1 星, standard (nandb)</h4>
 指令 <span class="inlinecode"><span class="id" title="var">Admitted</span></span> 被用作不完整证明的占位符。
    我们会在练习中用它来表示你需要完成的部分。你的任务就是将 <span class="inlinecode"><span class="id" title="var">Admitted</span></span>
    替换为具体的证明。

<div class="paragraph"> </div>

    移除“<span class="inlinecode"><span class="id" title="var">Admitted</span>.</span>”并补完以下函数的定义，然后确保下列每一个 <span class="inlinecode"><span class="id" title="keyword">Example</span></span>
    中的断言都能被 Coq 验证通过。（即仿照上文 <span class="inlinecode"><span class="id" title="var">orb</span></span> 测试的格式补充证明，
    并确保 Coq 接受它。）此函数应在两个输入中的任意一个（或者都）包含
    <span class="inlinecode"><span class="id" title="var">false</span></span> 时返回 <span class="inlinecode"><span class="id" title="var">true</span></span> 。 
    提示：如果 <span class="inlinecode"><span class="id" title="tactic">simpl</span></span> 在你的证明中未能化简目标，那是因为你可能并未使用
    <span class="inlinecode"><span class="id" title="keyword">match</span></span> 表达式定义你的 <span class="inlinecode"><span class="id" title="var">nandb</span></span>。尝试使用另一种 <span class="inlinecode"><span class="id" title="var">nandb</span></span> 的定义方式，
    或者直接跳过 <span class="inlinecode"><span class="id" title="tactic">simpl</span></span> 直接使用 <span class="inlinecode"><span class="id" title="tactic">reflexivity</span></span>。我们后面会解释为什么
    会发生这种情况。 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <a name="nandb"><span class="id" title="definition">nandb</span></a> (<span class="id" title="var">b<sub>1</sub></span>:<a class="idref" href="Basics.html#bool"><span class="id" title="inductive">bool</span></a>) (<span class="id" title="var">b<sub>2</sub></span>:<a class="idref" href="Basics.html#bool"><span class="id" title="inductive">bool</span></a>) : <a class="idref" href="Basics.html#bool"><span class="id" title="inductive">bool</span></a><br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;将本行替换成&nbsp;":=&nbsp;_你的_定义_&nbsp;."&nbsp;*)</span>. <span class="id" title="var">Admitted</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Example</span> <a name="test_nandb1"><span class="id" title="definition">test_nandb1</span></a>:               <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">(</span></a><a class="idref" href="Basics.html#nandb"><span class="id" title="axiom">nandb</span></a> <a class="idref" href="Basics.html#true"><span class="id" title="constructor">true</span></a> <a class="idref" href="Basics.html#false"><span class="id" title="constructor">false</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="Basics.html#true"><span class="id" title="constructor">true</span></a>.<br/>
<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" title="var">Admitted</span>.<br/>
<span class="id" title="keyword">Example</span> <a name="test_nandb2"><span class="id" title="definition">test_nandb2</span></a>:               <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">(</span></a><a class="idref" href="Basics.html#nandb"><span class="id" title="axiom">nandb</span></a> <a class="idref" href="Basics.html#false"><span class="id" title="constructor">false</span></a> <a class="idref" href="Basics.html#false"><span class="id" title="constructor">false</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="Basics.html#true"><span class="id" title="constructor">true</span></a>.<br/>
<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" title="var">Admitted</span>.<br/>
<span class="id" title="keyword">Example</span> <a name="test_nandb3"><span class="id" title="definition">test_nandb3</span></a>:               <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">(</span></a><a class="idref" href="Basics.html#nandb"><span class="id" title="axiom">nandb</span></a> <a class="idref" href="Basics.html#false"><span class="id" title="constructor">false</span></a> <a class="idref" href="Basics.html#true"><span class="id" title="constructor">true</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="Basics.html#true"><span class="id" title="constructor">true</span></a>.<br/>
<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" title="var">Admitted</span>.<br/>
<span class="id" title="keyword">Example</span> <a name="test_nandb4"><span class="id" title="definition">test_nandb4</span></a>:               <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">(</span></a><a class="idref" href="Basics.html#nandb"><span class="id" title="axiom">nandb</span></a> <a class="idref" href="Basics.html#true"><span class="id" title="constructor">true</span></a> <a class="idref" href="Basics.html#true"><span class="id" title="constructor">true</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="Basics.html#false"><span class="id" title="constructor">false</span></a>.<br/>
<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" title="var">Admitted</span>.<br/>
<font size=-2>&#9744;</font>
</div>

<div class="doc"> 
<div class="paragraph"> </div>

<a name="lab26"></a><h4 class="section">练习：1 星, standard (andb3)</h4>
 与此前相同，完成下面的 <span class="inlinecode"><span class="id" title="var">andb3</span></span> 函数。
    此函数应在所有输入均为 <span class="inlinecode"><span class="id" title="var">true</span></span> 时返回 <span class="inlinecode"><span class="id" title="var">true</span></span>，否则返回 <span class="inlinecode"><span class="id" title="var">false</span></span>。 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <a name="andb3"><span class="id" title="definition">andb3</span></a> (<span class="id" title="var">b<sub>1</sub></span>:<a class="idref" href="Basics.html#bool"><span class="id" title="inductive">bool</span></a>) (<span class="id" title="var">b<sub>2</sub></span>:<a class="idref" href="Basics.html#bool"><span class="id" title="inductive">bool</span></a>) (<span class="id" title="var">b<sub>3</sub></span>:<a class="idref" href="Basics.html#bool"><span class="id" title="inductive">bool</span></a>) : <a class="idref" href="Basics.html#bool"><span class="id" title="inductive">bool</span></a><br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;将本行替换成&nbsp;":=&nbsp;_你的_定义_&nbsp;."&nbsp;*)</span>. <span class="id" title="var">Admitted</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Example</span> <a name="test_andb31"><span class="id" title="definition">test_andb31</span></a>:                 <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">(</span></a><a class="idref" href="Basics.html#andb3"><span class="id" title="axiom">andb3</span></a> <a class="idref" href="Basics.html#true"><span class="id" title="constructor">true</span></a> <a class="idref" href="Basics.html#true"><span class="id" title="constructor">true</span></a> <a class="idref" href="Basics.html#true"><span class="id" title="constructor">true</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="Basics.html#true"><span class="id" title="constructor">true</span></a>.<br/>
<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" title="var">Admitted</span>.<br/>
<span class="id" title="keyword">Example</span> <a name="test_andb32"><span class="id" title="definition">test_andb32</span></a>:                 <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">(</span></a><a class="idref" href="Basics.html#andb3"><span class="id" title="axiom">andb3</span></a> <a class="idref" href="Basics.html#false"><span class="id" title="constructor">false</span></a> <a class="idref" href="Basics.html#true"><span class="id" title="constructor">true</span></a> <a class="idref" href="Basics.html#true"><span class="id" title="constructor">true</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="Basics.html#false"><span class="id" title="constructor">false</span></a>.<br/>
<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" title="var">Admitted</span>.<br/>
<span class="id" title="keyword">Example</span> <a name="test_andb33"><span class="id" title="definition">test_andb33</span></a>:                 <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">(</span></a><a class="idref" href="Basics.html#andb3"><span class="id" title="axiom">andb3</span></a> <a class="idref" href="Basics.html#true"><span class="id" title="constructor">true</span></a> <a class="idref" href="Basics.html#false"><span class="id" title="constructor">false</span></a> <a class="idref" href="Basics.html#true"><span class="id" title="constructor">true</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="Basics.html#false"><span class="id" title="constructor">false</span></a>.<br/>
<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" title="var">Admitted</span>.<br/>
<span class="id" title="keyword">Example</span> <a name="test_andb34"><span class="id" title="definition">test_andb34</span></a>:                 <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">(</span></a><a class="idref" href="Basics.html#andb3"><span class="id" title="axiom">andb3</span></a> <a class="idref" href="Basics.html#true"><span class="id" title="constructor">true</span></a> <a class="idref" href="Basics.html#true"><span class="id" title="constructor">true</span></a> <a class="idref" href="Basics.html#false"><span class="id" title="constructor">false</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="Basics.html#false"><span class="id" title="constructor">false</span></a>.<br/>
<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" title="var">Admitted</span>.<br/>
<font size=-2>&#9744;</font>
</div>


<div class="doc">
<a name="lab27"></a><h2 class="section">类型</h2>

<div class="paragraph"> </div>

 Coq 中的每个表达式都有类型，它描述了该表达式所计算的东西的类别。
    <span class="inlinecode"><span class="id" title="keyword">Check</span></span> 指令会让 Coq 显示一个表达式的类型。 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <a class="idref" href="Basics.html#true"><span class="id" title="constructor">true</span></a>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;true&nbsp;:&nbsp;bool&nbsp;*)</span><br/>
</div>

<div class="doc">
如果在被 <span class="inlinecode"><span class="id" title="keyword">Check</span></span> 的表达式后加上一个分号和你想验证的类型，那么 Coq 会
    验证该表达式是否属于你提供的类型。当两者不一致时，Coq 会报错并终止执行。 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <a class="idref" href="Basics.html#true"><span class="id" title="constructor">true</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;: <a class="idref" href="Basics.html#bool"><span class="id" title="inductive">bool</span></a>.<br/>
<span class="id" title="keyword">Check</span> (<a class="idref" href="Basics.html#negb"><span class="id" title="definition">negb</span></a> <a class="idref" href="Basics.html#true"><span class="id" title="constructor">true</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;: <a class="idref" href="Basics.html#bool"><span class="id" title="inductive">bool</span></a>.<br/>
</div>

<div class="doc">
像 <span class="inlinecode"><span class="id" title="var">negb</span></span> 这样的函数本身也是数据值，就像 <span class="inlinecode"><span class="id" title="var">true</span></span> 和 <span class="inlinecode"><span class="id" title="var">false</span></span> 一样。
    它们的类型被称为<i>'函数类型'</i>，用带箭头的类型表示。 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <a class="idref" href="Basics.html#negb"><span class="id" title="definition">negb</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;: <a class="idref" href="Basics.html#bool"><span class="id" title="inductive">bool</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="Basics.html#bool"><span class="id" title="inductive">bool</span></a>.<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" title="var">negb</span></span> 的类型写作 <span class="inlinecode"><span class="id" title="var">bool</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">bool</span></span>，读做“<span class="inlinecode"><span class="id" title="var">bool</span></span> 箭头 <span class="inlinecode"><span class="id" title="var">bool</span></span>”，
    可以理解为“给定一个 <span class="inlinecode"><span class="id" title="var">bool</span></span> 类型的输入，该函数产生一个 <span class="inlinecode"><span class="id" title="var">bool</span></span> 类型的输出。”
    同样，<span class="inlinecode"><span class="id" title="var">andb</span></span> 的类型写作 <span class="inlinecode"><span class="id" title="var">bool</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">bool</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">bool</span></span>，可以理解为
    “给定两个 <span class="inlinecode"><span class="id" title="var">bool</span></span> 类型的输入，该函数产生一个 <span class="inlinecode"><span class="id" title="var">bool</span></span> 类型的输出。” 
</div>

<div class="doc">
<a name="lab28"></a><h2 class="section">由旧类型构造新类型</h2>

<div class="paragraph"> </div>

 到目前为止，我们定义的类型都是“枚举类型”：它们的定义显式地枚举了
    一个元素的有限集，其中每个元素都只是一个裸构造子（译注：即无参数构造子）。
    下面是一个更加有趣的类型定义，其中有个构造子接受一个参数： 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <a name="rgb"><span class="id" title="inductive">rgb</span></a> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;| <a name="red"><span class="id" title="constructor">red</span></a><br/>
&nbsp;&nbsp;| <a name="green"><span class="id" title="constructor">green</span></a><br/>
&nbsp;&nbsp;| <a name="blue"><span class="id" title="constructor">blue</span></a>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Inductive</span> <a name="color"><span class="id" title="inductive">color</span></a> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;| <a name="black"><span class="id" title="constructor">black</span></a><br/>
&nbsp;&nbsp;| <a name="white"><span class="id" title="constructor">white</span></a><br/>
&nbsp;&nbsp;| <a name="primary"><span class="id" title="constructor">primary</span></a> (<span class="id" title="var">p</span> : <a class="idref" href="Basics.html#rgb"><span class="id" title="inductive">rgb</span></a>).<br/>
</div>

<div class="doc">
像 <span class="inlinecode"><span class="id" title="tactic">red</span></span>、<span class="inlinecode"><span class="id" title="var">green</span></span>、<span class="inlinecode"><span class="id" title="var">blue</span></span>、<span class="inlinecode"><span class="id" title="var">black</span></span>、<span class="inlinecode"><span class="id" title="var">white</span></span> 以及 <span class="inlinecode"><span class="id" title="var">primary</span></span>（还有
    <span class="inlinecode"><span class="id" title="var">true</span></span>、<span class="inlinecode"><span class="id" title="var">false</span></span>、<span class="inlinecode"><span class="id" title="var">monday</span></span> 等）这样的原子标识符叫做<i>'构造子（Constructor）'</i>。

<div class="paragraph"> </div>

    我们可以用它们来构建<i>'构造子表达式（Constructor Expression）'</i>，
    其中每一个要么是一个简单的构造子，要么就是一个构造子应用于一个或多个参数
    （每个这样的参数也都是构造子表达式）。 
<div class="paragraph"> </div>

 我们来仔细研究一下。每个归纳定义的类型（如 <span class="inlinecode"><span class="id" title="var">day</span></span>、<span class="inlinecode"><span class="id" title="var">bool</span></span>、<span class="inlinecode"><span class="id" title="var">rgb</span></span>、<span class="inlinecode"><span class="id" title="var">color</span></span> 等）
    都描述了一组由<i>'构造子'</i>构成的<i>'构造子表达式'</i>。

<div class="paragraph"> </div>

<ul class="doclist">
<li> 我们从有限的一组<i>'构造子'</i>开始。例如
      <span class="inlinecode"><span class="id" title="tactic">red</span></span>、<span class="inlinecode"><span class="id" title="var">primary</span></span>、<span class="inlinecode"><span class="id" title="var">true</span></span>、<span class="inlinecode"><span class="id" title="var">false</span></span>、<span class="inlinecode"><span class="id" title="var">monday</span></span>
      等等都是构造子。

<div class="paragraph"> </div>


</li>
<li> <i>'构造子表达式'</i>通过将构造子应用到一个或多个构造子表达式上构成。例如
         <span class="inlinecode"><span class="id" title="tactic">red</span></span>、<span class="inlinecode"><span class="id" title="var">true</span></span>、<span class="inlinecode"><span class="id" title="var">primary</span></span>、<span class="inlinecode"><span class="id" title="var">primary</span></span> <span class="inlinecode"><span class="id" title="tactic">red</span></span>、<span class="inlinecode"><span class="id" title="tactic">red</span></span> <span class="inlinecode"><span class="id" title="var">primary</span></span>、<span class="inlinecode"><span class="id" title="tactic">red</span></span> <span class="inlinecode"><span class="id" title="var">true</span></span>、
         <span class="inlinecode"><span class="id" title="var">primary</span></span> <span class="inlinecode">(<span class="id" title="var">primary</span></span> <span class="inlinecode"><span class="id" title="var">primary</span>)</span> 等等

<div class="paragraph"> </div>


</li>
<li> 每个 <span class="inlinecode"><span class="id" title="keyword">Inductive</span></span> 定义都刻画了一个构造子表达式的子集并赋予了它们名字，如
      <span class="inlinecode"><span class="id" title="var">bool</span></span>、<span class="inlinecode"><span class="id" title="var">rgb</span></span> 或 <span class="inlinecode"><span class="id" title="var">color</span></span>。

</li>
</ul>

<div class="paragraph"> </div>

 具体来说，<span class="inlinecode"><span class="id" title="var">rgb</span></span> 和 <span class="inlinecode"><span class="id" title="var">color</span></span> 的定义描述了如何构造这两个集合中的构造子表达式：

<div class="paragraph"> </div>

<ul class="doclist">
<li> 构造子表达式 <span class="inlinecode"><span class="id" title="tactic">red</span></span>、<span class="inlinecode"><span class="id" title="var">green</span></span> 和 <span class="inlinecode"><span class="id" title="var">blue</span></span> 属于集合 <span class="inlinecode"><span class="id" title="var">rgb</span></span>；

</li>
<li> 构造子表达式 <span class="inlinecode"><span class="id" title="var">black</span></span> 和 <span class="inlinecode"><span class="id" title="var">white</span></span> 属于集合 <span class="inlinecode"><span class="id" title="var">color</span></span>；

</li>
<li> 若 <span class="inlinecode"><span class="id" title="var">p</span></span> 是属于 <span class="inlinecode"><span class="id" title="var">rgb</span></span> 的构造子表达式，则 <span class="inlinecode"><span class="id" title="var">primary</span></span> <span class="inlinecode"><span class="id" title="var">p</span></span>（读作“构造子 <span class="inlinecode"><span class="id" title="var">primary</span></span>
      应用于参数 <span class="inlinecode"><span class="id" title="var">p</span></span>）是属于集合 <span class="inlinecode"><span class="id" title="var">color</span></span> 的构造子表达式；且

</li>
<li> 通过这些方式构造的构造子表达式<i>'只属于'</i>集合 <span class="inlinecode"><span class="id" title="var">rgb</span></span> 和 <span class="inlinecode"><span class="id" title="var">color</span></span>。 
</li>
</ul>

<div class="paragraph"> </div>

 我们可以像之前的 <span class="inlinecode"><span class="id" title="var">day</span></span> 和 <span class="inlinecode"><span class="id" title="var">bool</span></span> 那样用模式匹配为 <span class="inlinecode"><span class="id" title="var">color</span></span> 定义函数。 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <a name="monochrome"><span class="id" title="definition">monochrome</span></a> (<span class="id" title="var">c</span> : <a class="idref" href="Basics.html#color"><span class="id" title="inductive">color</span></a>) : <a class="idref" href="Basics.html#bool"><span class="id" title="inductive">bool</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Basics.html#c"><span class="id" title="variable">c</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| <a class="idref" href="Basics.html#black"><span class="id" title="constructor">black</span></a> ⇒ <a class="idref" href="Basics.html#true"><span class="id" title="constructor">true</span></a><br/>
&nbsp;&nbsp;| <a class="idref" href="Basics.html#white"><span class="id" title="constructor">white</span></a> ⇒ <a class="idref" href="Basics.html#true"><span class="id" title="constructor">true</span></a><br/>
&nbsp;&nbsp;| <a class="idref" href="Basics.html#primary"><span class="id" title="constructor">primary</span></a> <span class="id" title="var">p</span> ⇒ <a class="idref" href="Basics.html#false"><span class="id" title="constructor">false</span></a><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>
</div>

<div class="doc">
鉴于 <span class="inlinecode"><span class="id" title="var">primary</span></span> 构造子接收一个参数，匹配到 <span class="inlinecode"><span class="id" title="var">primary</span></span> 的模式应当带有一个
    变量或常量。变量可以取任意名称，如上文所示；常量需有适当的类型，例如： 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <a name="isred"><span class="id" title="definition">isred</span></a> (<span class="id" title="var">c</span> : <a class="idref" href="Basics.html#color"><span class="id" title="inductive">color</span></a>) : <a class="idref" href="Basics.html#bool"><span class="id" title="inductive">bool</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Basics.html#c"><span class="id" title="variable">c</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| <a class="idref" href="Basics.html#black"><span class="id" title="constructor">black</span></a> ⇒ <a class="idref" href="Basics.html#false"><span class="id" title="constructor">false</span></a><br/>
&nbsp;&nbsp;| <a class="idref" href="Basics.html#white"><span class="id" title="constructor">white</span></a> ⇒ <a class="idref" href="Basics.html#false"><span class="id" title="constructor">false</span></a><br/>
&nbsp;&nbsp;| <a class="idref" href="Basics.html#primary"><span class="id" title="constructor">primary</span></a> <a class="idref" href="Basics.html#red"><span class="id" title="constructor">red</span></a> ⇒ <a class="idref" href="Basics.html#true"><span class="id" title="constructor">true</span></a><br/>
&nbsp;&nbsp;| <a class="idref" href="Basics.html#primary"><span class="id" title="constructor">primary</span></a> <span class="id" title="var">_</span> ⇒ <a class="idref" href="Basics.html#false"><span class="id" title="constructor">false</span></a><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>
</div>

<div class="doc">
这里的模式 <span class="inlinecode"><span class="id" title="var">primary</span></span> <span class="inlinecode"><span class="id" title="var">_</span></span> 是“构造子 <span class="inlinecode"><span class="id" title="var">primary</span></span> 应用到除 <span class="inlinecode"><span class="id" title="tactic">red</span></span>
    之外的任何 <span class="inlinecode"><span class="id" title="var">rgb</span></span> 构造子上”的简写形式（通配模式 <span class="inlinecode"><span class="id" title="var">_</span></span> 的效果与
    <span class="inlinecode"><span class="id" title="var">monochrome</span></span> 定义中的哑（dummy）模式变量 <span class="inlinecode"><span class="id" title="var">p</span></span> 相同。） 
</div>

<div class="doc">
<a name="lab29"></a><h2 class="section">元组</h2>

<div class="paragraph"> </div>

 一个多参数的单构造子可以用来创建元组类型。例如，为了让一个
    半字节（nybble）表示四个比特。我们首先定义一个 <span class="inlinecode"><span class="id" title="var">bit</span></span> 数据类型
    来类比 <span class="inlinecode"><span class="id" title="var">bool</span></span> 数据。并且使用 <span class="inlinecode"><span class="id" title="var">B<sub>0</sub></span></span> 和 <span class="inlinecode"><span class="id" title="var">B<sub>1</sub></span></span> 两种构造子来表示其可能的取值。
    最后定义 <span class="inlinecode"><span class="id" title="var">nybble</span></span> 这种数据类型，也就是一个四比特的元组。
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <a name="bit"><span class="id" title="inductive">bit</span></a> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;| <a name="B<sub>0</sub>"><span class="id" title="constructor">B<sub>0</sub></span></a><br/>
&nbsp;&nbsp;| <a name="B<sub>1</sub>"><span class="id" title="constructor">B<sub>1</sub></span></a>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Inductive</span> <a name="nybble"><span class="id" title="inductive">nybble</span></a> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;| <a name="bits"><span class="id" title="constructor">bits</span></a> (<span class="id" title="var">b<sub>0</sub></span> <span class="id" title="var">b<sub>1</sub></span> <span class="id" title="var">b<sub>2</sub></span> <span class="id" title="var">b<sub>3</sub></span> : <a class="idref" href="Basics.html#bit"><span class="id" title="inductive">bit</span></a>).<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Check</span> (<a class="idref" href="Basics.html#bits"><span class="id" title="constructor">bits</span></a> <a class="idref" href="Basics.html#B<sub>1</sub>"><span class="id" title="constructor">B<sub>1</sub></span></a> <a class="idref" href="Basics.html#B<sub>0</sub>"><span class="id" title="constructor">B<sub>0</sub></span></a> <a class="idref" href="Basics.html#B<sub>1</sub>"><span class="id" title="constructor">B<sub>1</sub></span></a> <a class="idref" href="Basics.html#B<sub>0</sub>"><span class="id" title="constructor">B<sub>0</sub></span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;: <a class="idref" href="Basics.html#nybble"><span class="id" title="inductive">nybble</span></a>.<br/>
</div>

<div class="doc">
这里的 <span class="inlinecode"><span class="id" title="var">bit</span></span> 构造子起到了对它内容的包装作用。
    解包可以通过模式匹配来实现，就如同下面的 <span class="inlinecode"><span class="id" title="var">all_zero</span></span> 函数一样，
    其通过解包来验证一个半字节的所有比特是否都为 <span class="inlinecode"><span class="id" title="var">B<sub>0</sub></span></span>。
    我们用<i>'通配符'</i> <span class="inlinecode"><span class="id" title="var">_</span></span> 来避免创建不需要的变量名。 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <a name="all_zero"><span class="id" title="definition">all_zero</span></a> (<span class="id" title="var">nb</span> : <a class="idref" href="Basics.html#nybble"><span class="id" title="inductive">nybble</span></a>) : <a class="idref" href="Basics.html#bool"><span class="id" title="inductive">bool</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Basics.html#nb"><span class="id" title="variable">nb</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| (<a class="idref" href="Basics.html#bits"><span class="id" title="constructor">bits</span></a> <a class="idref" href="Basics.html#B<sub>0</sub>"><span class="id" title="constructor">B<sub>0</sub></span></a> <a class="idref" href="Basics.html#B<sub>0</sub>"><span class="id" title="constructor">B<sub>0</sub></span></a> <a class="idref" href="Basics.html#B<sub>0</sub>"><span class="id" title="constructor">B<sub>0</sub></span></a> <a class="idref" href="Basics.html#B<sub>0</sub>"><span class="id" title="constructor">B<sub>0</sub></span></a>) ⇒ <a class="idref" href="Basics.html#true"><span class="id" title="constructor">true</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| (<a class="idref" href="Basics.html#bits"><span class="id" title="constructor">bits</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>) ⇒ <a class="idref" href="Basics.html#false"><span class="id" title="constructor">false</span></a><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Compute</span> (<a class="idref" href="Basics.html#all_zero"><span class="id" title="definition">all_zero</span></a> (<a class="idref" href="Basics.html#bits"><span class="id" title="constructor">bits</span></a> <a class="idref" href="Basics.html#B<sub>1</sub>"><span class="id" title="constructor">B<sub>1</sub></span></a> <a class="idref" href="Basics.html#B<sub>0</sub>"><span class="id" title="constructor">B<sub>0</sub></span></a> <a class="idref" href="Basics.html#B<sub>1</sub>"><span class="id" title="constructor">B<sub>1</sub></span></a> <a class="idref" href="Basics.html#B<sub>0</sub>"><span class="id" title="constructor">B<sub>0</sub></span></a>)).<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;false&nbsp;:&nbsp;bool&nbsp;*)</span><br/>
<span class="id" title="keyword">Compute</span> (<a class="idref" href="Basics.html#all_zero"><span class="id" title="definition">all_zero</span></a> (<a class="idref" href="Basics.html#bits"><span class="id" title="constructor">bits</span></a> <a class="idref" href="Basics.html#B<sub>0</sub>"><span class="id" title="constructor">B<sub>0</sub></span></a> <a class="idref" href="Basics.html#B<sub>0</sub>"><span class="id" title="constructor">B<sub>0</sub></span></a> <a class="idref" href="Basics.html#B<sub>0</sub>"><span class="id" title="constructor">B<sub>0</sub></span></a> <a class="idref" href="Basics.html#B<sub>0</sub>"><span class="id" title="constructor">B<sub>0</sub></span></a>)).<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;true&nbsp;:&nbsp;bool&nbsp;*)</span><br/>
</div>

<div class="doc">
<a name="lab30"></a><h2 class="section">模块</h2>

<div class="paragraph"> </div>

 Coq 提供了<i>'模块系统'</i>来帮助组织大规模的开发。在本课程中，
    我们不太会用到这方面的特性。不过其中有一点非常有用：
    如果我们将一组定义放在 <span class="inlinecode"><span class="id" title="keyword">Module</span></span> <span class="inlinecode"><span class="id" title="var">X</span></span> 和 <span class="inlinecode"><span class="id" title="keyword">End</span></span> <span class="inlinecode"><span class="id" title="var">X</span></span> 标记之间，那么在文件中的
    <span class="inlinecode"><span class="id" title="keyword">End</span></span> 之后，我们就可以通过像 <span class="inlinecode"><span class="id" title="var">X.foo</span></span> 这样的名字来引用，而不必直接用
    <span class="inlinecode"><span class="id" title="var">foo</span></span> 了。在这里，我们通过此特性在内部模块中引入了 <span class="inlinecode"><span class="id" title="var">nat</span></span> 类型的定义，
    这样就不会覆盖标准库中的同名定义了（我们会在本书后面的部分中使用它，
    因为它提供了一些简便的特殊记法。）
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <a name="NatPlayground"><span class="id" title="module">NatPlayground</span></a>.<br/>
</div>

<div class="doc">
<a name="lab31"></a><h2 class="section">数值</h2>

<div class="paragraph"> </div>

 目前我们定义的所有类型都是有限的。无论是像 <span class="inlinecode"><span class="id" title="var">day</span></span>, <span class="inlinecode"><span class="id" title="var">bool</span></span> 和 <span class="inlinecode"><span class="id" title="var">bit</span></span> 
    这样的“枚举类型”，抑或是像 <span class="inlinecode"><span class="id" title="var">nybble</span></span> 这样基于“枚举类型”的元组类型，
    本质上都是有限的集合。而自然数（natural numbers）是一个无限集合，
    因此我们需要一种更强大的类型声明方式来表示它们。

<div class="paragraph"> </div>

    数字的表示方法有许多种。我们最为熟悉的便是十进制（base 10），利用
    0～9 十个数字来表示一个数，例如用 1，2 和 3 来表示 123 （一百二十三）。
    你或许也接触过十六进制（base 16），在十六进制中，它被表示为 7B。类似的还有
    173 （八进制表示）和 111011（二进制表示）。我们可以使用枚举类型
    来定义以上任何一种数字表示方式。它们在不同的场景下有着不同的用途。

<div class="paragraph"> </div>

    二进制表示在计算机硬件中起着举足轻重的作用。它只需要两种不同的电平
    来表示，因此它的硬件电路可以被设计十分简单。同样的，
    我们也希望选择一种自然数的表示方式，来让我们的_证明_变得更加简单。

<div class="paragraph"> </div>

    实际上，比起二进制，还有一种更加简单的数字表示方式，一进制（base 1），
    也就是只使用单个数字的表示方式（就如同我们的祖先山顶洞人在洞穴上
    刻“痕迹”计算日子一般）。为了在 Coq 中表示一进制数，我们使用两个构造子。
    大写的 <span class="inlinecode"><span class="id" title="var">O</span></span> 构造子用来表示“零”，而大写的 <span class="inlinecode"><span class="id" title="var">S</span></span> 构造子用来表示“后继”
    （或者洞穴上的“痕迹”）。当 <span class="inlinecode"><span class="id" title="var">S</span></span> 构造子被应用于一个自然数 n 的表示上时，
    结果会是自然数 n + 1 的表示。下面是完整的数据类型定义。 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <a name="NatPlayground.nat"><span class="id" title="inductive">nat</span></a> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;| <a name="NatPlayground.O"><span class="id" title="constructor">O</span></a><br/>
&nbsp;&nbsp;| <a name="NatPlayground.S"><span class="id" title="constructor">S</span></a> (<span class="id" title="var">n</span> : <a class="idref" href="Basics.html#nat"><span class="id" title="inductive">nat</span></a>).<br/>
</div>

<div class="doc">
在这种定义下， 0 被表示为 <span class="inlinecode"><span class="id" title="var">O</span></span>, 1 则被表示为 <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">O</span></span>,
    2 则是 <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">O</span>)</span>，以此类推 
<div class="paragraph"> </div>

 非形式化地说，此定义中的子句可读作：
<ul class="doclist">
<li> <span class="inlinecode"><span class="id" title="var">O</span></span> 是一个自然数（注意这里是字母“<span class="inlinecode"><span class="id" title="var">O</span></span>”，不是数字“<span class="inlinecode">0</span>”）。

</li>
<li> <span class="inlinecode"><span class="id" title="var">S</span></span> 可被放在一个自然数之前来产生另一个自然数 ——
        也就是说，如果 <span class="inlinecode"><span class="id" title="var">n</span></span> 是一个自然数，那么 <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> 也是。 
</li>
</ul>

<div class="paragraph"> </div>

 同样，我们来仔细观察这个定义。
    <span class="inlinecode"><span class="id" title="var">nat</span></span> 的定义描述了集合 <span class="inlinecode"><span class="id" title="var">nat</span></span> 中的表达式是如何构造的：

<div class="paragraph"> </div>

<ul class="doclist">
<li> 构造子表达式 <span class="inlinecode"><span class="id" title="var">O</span></span> 属于集合 <span class="inlinecode"><span class="id" title="var">nat</span></span>；

</li>
<li> 如果 <span class="inlinecode"><span class="id" title="var">n</span></span> 是属于集合 <span class="inlinecode"><span class="id" title="var">nat</span></span> 的构造子表达式，
      那么 <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> 也是属于集合 <span class="inlinecode"><span class="id" title="var">nat</span></span> 的构造子表达式；并且

</li>
<li> 只有以这两种产生的方式构造字表达式才属于集合 <span class="inlinecode"><span class="id" title="var">nat</span></span>。 
</li>
</ul>

<div class="paragraph"> </div>

 这些条件精确刻画了这个“归纳” <span class="inlinecode"><span class="id" title="keyword">Inductive</span></span> 声明。它们意味着，构造子表达式 <span class="inlinecode"><span class="id" title="var">O</span></span>、
    <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">O</span></span>、<span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">O</span>)</span>、<span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">O</span>))</span> 等等都属于集合 <span class="inlinecode"><span class="id" title="var">nat</span></span>，而其它的构造子表达式，如
    <span class="inlinecode"><span class="id" title="var">true</span></span>、<span class="inlinecode"><span class="id" title="var">andb</span></span> <span class="inlinecode"><span class="id" title="var">true</span></span> <span class="inlinecode"><span class="id" title="var">false</span></span>、<span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">false</span>)</span> 以及 <span class="inlinecode"><span class="id" title="var">O</span></span> <span class="inlinecode">(<span class="id" title="var">O</span></span> <span class="inlinecode">(<span class="id" title="var">O</span></span> <span class="inlinecode"><span class="id" title="var">S</span>))</span> 等则不属于 <span class="inlinecode"><span class="id" title="var">nat</span></span>。

<div class="paragraph"> </div>

    关键之处在于，我们目前只是定义了一种数字的<i>'表示'</i>方式，
    即一种写下它们的方式。名称 <span class="inlinecode"><span class="id" title="var">O</span></span> 和 <span class="inlinecode"><span class="id" title="var">S</span></span> 是任意的，在这一点上它们没有特殊的意义，
    它们只是我们能用来写下数字的两个不同的记号（以及一个说明了任何 <span class="inlinecode"><span class="id" title="var">nat</span></span>
    都能写成一串 <span class="inlinecode"><span class="id" title="var">S</span></span> 后跟一个 <span class="inlinecode"><span class="id" title="var">O</span></span> 的规则）。如果你喜欢，完全可以将同样的定义写成： 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <a name="NatPlayground.nat'"><span class="id" title="inductive">nat'</span></a> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;| <a name="NatPlayground.stop"><span class="id" title="constructor">stop</span></a><br/>
&nbsp;&nbsp;| <a name="NatPlayground.tick"><span class="id" title="constructor">tick</span></a> (<span class="id" title="var">foo</span> : <a class="idref" href="Basics.html#nat'"><span class="id" title="inductive">nat'</span></a>).<br/>
</div>

<div class="doc">
这些记号的<i>'解释'</i>完全取决于我们如何用它进行计算。 
<div class="paragraph"> </div>

 我们可以像之前的布尔值或日期那样，
    编写一个函数来对上述自然数的表示进行模式匹配。
    例如，以下为前趋函数：
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <a name="NatPlayground.pred"><span class="id" title="definition">pred</span></a> (<span class="id" title="var">n</span> : <a class="idref" href="Basics.html#NatPlayground.nat"><span class="id" title="inductive">nat</span></a>) : <a class="idref" href="Basics.html#NatPlayground.nat"><span class="id" title="inductive">nat</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Basics.html#n"><span class="id" title="variable">n</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Basics.html#NatPlayground.O"><span class="id" title="constructor">O</span></a> ⇒ <a class="idref" href="Basics.html#NatPlayground.O"><span class="id" title="constructor">O</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Basics.html#NatPlayground.S"><span class="id" title="constructor">S</span></a> <span class="id" title="var">n'</span> ⇒ <span class="id" title="var">n'</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>
</div>

<div class="doc">
第二个分支可以读作：“如果 <span class="inlinecode"><span class="id" title="var">n</span></span> 对于某个 <span class="inlinecode"><span class="id" title="var">n'</span></span> 的形式为 <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n'</span></span>，
    那么就返回 <span class="inlinecode"><span class="id" title="var">n'</span></span>。” 
<div class="paragraph"> </div>

 下面的 <span class="inlinecode"><span class="id" title="keyword">End</span></span> 指令会关闭当前的模块，所以 <span class="inlinecode"><span class="id" title="var">nat</span></span> 会重新代表标准库中的类型而非我们
    自己定义的 <span class="inlinecode"><span class="id" title="var">nat</span></span>。 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">End</span> <a class="idref" href="Basics.html#NatPlayground"><span class="id" title="module">NatPlayground</span></a>.<br/>
</div>

<div class="doc">
为了让自然数使用起来更加自然，Coq 内建了一小部分解析打印功能：
    普通的十进制数可视为“一进制”自然数的另一种记法，以代替 <span class="inlinecode"><span class="id" title="var">S</span></span> 与 <span class="inlinecode"><span class="id" title="var">O</span></span> 构造子；
    反过来，Coq 也会默认将自然数打印为十进制形式： 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> (<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> (<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> (<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> (<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#O"><span class="id" title="constructor">O</span></a>)))).<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;4&nbsp;:&nbsp;nat&nbsp;*)</span><br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Definition</span> <a name="minustwo"><span class="id" title="definition">minustwo</span></a> (<span class="id" title="var">n</span> : <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>) : <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Basics.html#n"><span class="id" title="variable">n</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#O"><span class="id" title="constructor">O</span></a> ⇒ <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#O"><span class="id" title="constructor">O</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#O"><span class="id" title="constructor">O</span></a> ⇒ <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#O"><span class="id" title="constructor">O</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> (<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> <span class="id" title="var">n'</span>) ⇒ <span class="id" title="var">n'</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Compute</span> (<a class="idref" href="Basics.html#minustwo"><span class="id" title="definition">minustwo</span></a> 4).<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;2&nbsp;:&nbsp;nat&nbsp;*)</span><br/>
</div>

<div class="doc">
构造子 <span class="inlinecode"><span class="id" title="var">S</span></span> 的类型为 <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">nat</span></span>，与 <span class="inlinecode"><span class="id" title="var">pred</span></span> 和 <span class="inlinecode"><span class="id" title="var">minustwo</span></span> 之类的函数相同： 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a>        : <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>.<br/>
<span class="id" title="keyword">Check</span> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Peano.html#pred"><span class="id" title="abbreviation">pred</span></a>     : <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>.<br/>
<span class="id" title="keyword">Check</span> <a class="idref" href="Basics.html#minustwo"><span class="id" title="definition">minustwo</span></a> : <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>.<br/>
</div>

<div class="doc">
以上三个东西均可作用于自然数，并产生自然数结果，但第一个 <span class="inlinecode"><span class="id" title="var">S</span></span>
    与后两者有本质区别：<span class="inlinecode"><span class="id" title="var">pred</span></span> 和 <span class="inlinecode"><span class="id" title="var">minustwo</span></span> 这类函数是通过给定的<i>'计算规则'</i>定义的——
    例如 <span class="inlinecode"><span class="id" title="var">pred</span></span> 的定义表明 <span class="inlinecode"><span class="id" title="var">pred</span></span> <span class="inlinecode">2</span> 可化简为 <span class="inlinecode">1</span>——但 <span class="inlinecode"><span class="id" title="var">S</span></span> 的定义不包含此类行为。
    虽然 <span class="inlinecode"><span class="id" title="var">S</span></span> 可以作用于参数这点与函数<i>'相似'</i>，但其作用仅限于构造数字，而并不用于计算。

<div class="paragraph"> </div>

    （考虑标准的十进制数：数字 <span class="inlinecode">1</span> 不代表任何计算，只表示一部分数据。
    用 <span class="inlinecode">111</span> 指代数字一百一十一，实则使用三个 <span class="inlinecode">1</span> 符号表示此数各位。）

<div class="paragraph"> </div>

    现在我们来为数值定义更多的函数。

<div class="paragraph"> </div>

    简单的模式匹配不足以描述很多有趣的数值运算，我们还需要递归定义。
    例如：给定自然数 <span class="inlinecode"><span class="id" title="var">n</span></span>，欲判定其是否为偶数，则需递归检查 <span class="inlinecode"><span class="id" title="var">n</span>-2</span> 是否为偶数。
    关键字 <span class="inlinecode"><span class="id" title="keyword">Fixpoint</span></span> 可用于定义此类函数。 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <a name="evenb"><span class="id" title="definition">evenb</span></a> (<span class="id" title="var">n</span>:<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>) : <a class="idref" href="Basics.html#bool"><span class="id" title="inductive">bool</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Basics.html#n"><span class="id" title="variable">n</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#O"><span class="id" title="constructor">O</span></a>        ⇒ <a class="idref" href="Basics.html#true"><span class="id" title="constructor">true</span></a><br/>
&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#O"><span class="id" title="constructor">O</span></a>      ⇒ <a class="idref" href="Basics.html#false"><span class="id" title="constructor">false</span></a><br/>
&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> (<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> <span class="id" title="var">n'</span>) ⇒ <a class="idref" href="Basics.html#evenb"><span class="id" title="definition">evenb</span></a> <span class="id" title="var">n'</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>
</div>

<div class="doc">
我们可以使用类似的 <span class="inlinecode"><span class="id" title="keyword">Fixpoint</span></span> 声明来定义 <span class="inlinecode"><span class="id" title="var">odd</span></span> 函数，
    不过还有种更简单方式：
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <a name="oddb"><span class="id" title="definition">oddb</span></a> (<span class="id" title="var">n</span>:<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>) : <a class="idref" href="Basics.html#bool"><span class="id" title="inductive">bool</span></a> :=<br/>
&nbsp;&nbsp;<a class="idref" href="Basics.html#negb"><span class="id" title="definition">negb</span></a> (<a class="idref" href="Basics.html#evenb"><span class="id" title="definition">evenb</span></a> <a class="idref" href="Basics.html#n"><span class="id" title="variable">n</span></a>).<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Example</span> <a name="test_oddb1"><span class="id" title="definition">test_oddb1</span></a>:    <a class="idref" href="Basics.html#oddb"><span class="id" title="definition">oddb</span></a> 1 <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="Basics.html#true"><span class="id" title="constructor">true</span></a>.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>
<span class="id" title="keyword">Example</span> <a name="test_oddb2"><span class="id" title="definition">test_oddb2</span></a>:    <a class="idref" href="Basics.html#oddb"><span class="id" title="definition">oddb</span></a> 4 <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="Basics.html#false"><span class="id" title="constructor">false</span></a>.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
（如果你逐步检查完这些证明，就会发现 <span class="inlinecode"><span class="id" title="tactic">simpl</span></span> 其实没什么作用
    —— 所有工作都被 <span class="inlinecode"><span class="id" title="tactic">reflexivity</span></span> 完成了。我们之后会讨论为什么会这样。)

<div class="paragraph"> </div>

    当然，我们也可以用递归定义多参函数。  
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <a name="NatPlayground2"><span class="id" title="module">NatPlayground2</span></a>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Fixpoint</span> <a name="NatPlayground2.plus"><span class="id" title="definition">plus</span></a> (<span class="id" title="var">n</span> : <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>) (<span class="id" title="var">m</span> : <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>) : <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Basics.html#n"><span class="id" title="variable">n</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#O"><span class="id" title="constructor">O</span></a> ⇒ <a class="idref" href="Basics.html#m"><span class="id" title="variable">m</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> <span class="id" title="var">n'</span> ⇒ <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> (<a class="idref" href="Basics.html#plus"><span class="id" title="definition">plus</span></a> <span class="id" title="var">n'</span> <a class="idref" href="Basics.html#m"><span class="id" title="variable">m</span></a>)<br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>
</div>

<div class="doc">
三加二等于五，不出意料。 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Compute</span> (<a class="idref" href="Basics.html#NatPlayground2.plus"><span class="id" title="definition">plus</span></a> 3 2).<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;5&nbsp;:&nbsp;nat&nbsp;*)</span><br/>
</div>

<div class="doc">
Coq 所执行的化简步骤如下所示： 
</div>
<div class="code">

<br/>
<span class="comment">(*&nbsp;&nbsp;&nbsp;<span class="inlinecode"><span class="id" title="var">plus</span></span> <span class="inlinecode">3</span> <span class="inlinecode">2</span><br/>
i.e.&nbsp;<span class="inlinecode"><span class="id" title="var">plus</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">O</span>)))</span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">O</span>))</span><br/>
&nbsp;==&gt;&nbsp;<span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">plus</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">O</span>))</span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">O</span>)))</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（根据第二个&nbsp;<span class="inlinecode"><span class="id" title="keyword">match</span></span>&nbsp;子句）<br/>
&nbsp;==&gt;&nbsp;<span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">plus</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">O</span>)</span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">O</span>))))</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（根据第二个&nbsp;<span class="inlinecode"><span class="id" title="keyword">match</span></span>&nbsp;子句）<br/>
&nbsp;==&gt;&nbsp;<span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">plus</span></span> <span class="inlinecode"><span class="id" title="var">O</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">O</span>)))))</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（根据第二个&nbsp;<span class="inlinecode"><span class="id" title="keyword">match</span></span>&nbsp;子句）<br/>
&nbsp;==&gt;&nbsp;<span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">O</span>))))</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（根据第一个&nbsp;<span class="inlinecode"><span class="id" title="keyword">match</span></span>&nbsp;子句）<br/>
i.e.&nbsp;<span class="inlinecode">5</span>&nbsp;&nbsp;*)</span><br/>
</div>

<div class="doc">
为了书写方便，如果两个或更多参数具有相同的类型，那么它们可以写在一起。
    在下面的定义中，<span class="inlinecode">(<span class="id" title="var">n</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span>)</span> 的意思与 <span class="inlinecode">(<span class="id" title="var">n</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span>)</span> <span class="inlinecode">(<span class="id" title="var">m</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span>)</span> 相同。 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <a name="NatPlayground2.mult"><span class="id" title="definition">mult</span></a> (<span class="id" title="var">n</span> <span class="id" title="var">m</span> : <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>) : <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Basics.html#n"><span class="id" title="variable">n</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#O"><span class="id" title="constructor">O</span></a> ⇒ <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#O"><span class="id" title="constructor">O</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> <span class="id" title="var">n'</span> ⇒ <a class="idref" href="Basics.html#NatPlayground2.plus"><span class="id" title="definition">plus</span></a> <a class="idref" href="Basics.html#m"><span class="id" title="variable">m</span></a> (<a class="idref" href="Basics.html#mult"><span class="id" title="definition">mult</span></a> <span class="id" title="var">n'</span> <a class="idref" href="Basics.html#m"><span class="id" title="variable">m</span></a>)<br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Example</span> <a name="NatPlayground2.test_mult1"><span class="id" title="definition">test_mult1</span></a>: <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">(</span></a><a class="idref" href="Basics.html#NatPlayground2.mult"><span class="id" title="definition">mult</span></a> 3 3<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> 9.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
你可以在两个表达式之间添加逗号来同时匹配它们：
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <a name="NatPlayground2.minus"><span class="id" title="definition">minus</span></a> (<span class="id" title="var">n</span> <span class="id" title="var">m</span>:<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>) : <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Basics.html#n"><span class="id" title="variable">n</span></a>, <a class="idref" href="Basics.html#m"><span class="id" title="variable">m</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#O"><span class="id" title="constructor">O</span></a>   , <span class="id" title="var">_</span>    ⇒ <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#O"><span class="id" title="constructor">O</span></a><br/>
&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> <span class="id" title="var">_</span> , <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#O"><span class="id" title="constructor">O</span></a>    ⇒ <a class="idref" href="Basics.html#n"><span class="id" title="variable">n</span></a><br/>
&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> <span class="id" title="var">n'</span>, <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> <span class="id" title="var">m'</span> ⇒ <a class="idref" href="Basics.html#minus"><span class="id" title="definition">minus</span></a> <span class="id" title="var">n'</span> <span class="id" title="var">m'</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">End</span> <a class="idref" href="Basics.html#NatPlayground2"><span class="id" title="module">NatPlayground2</span></a>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Fixpoint</span> <a name="exp"><span class="id" title="definition">exp</span></a> (<span class="id" title="var">base</span> <span class="id" title="var">power</span> : <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>) : <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Basics.html#power"><span class="id" title="variable">power</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#O"><span class="id" title="constructor">O</span></a> ⇒ <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#O"><span class="id" title="constructor">O</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> <span class="id" title="var">p</span> ⇒ <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Peano.html#mult"><span class="id" title="abbreviation">mult</span></a> <a class="idref" href="Basics.html#base"><span class="id" title="variable">base</span></a> (<a class="idref" href="Basics.html#exp"><span class="id" title="definition">exp</span></a> <a class="idref" href="Basics.html#base"><span class="id" title="variable">base</span></a> <span class="id" title="var">p</span>)<br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>
</div>

<div class="doc">
<a name="lab32"></a><h4 class="section">练习：1 星, standard (factorial)</h4>
 回想一下标准的阶乘函数：
<pre>
       factorial(0)  =  1
       factorial(n)  =  n * factorial(n-1)     (if n&gt;0)
</pre>
    把它翻译成 Coq 代码。 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <a name="factorial"><span class="id" title="definition">factorial</span></a> (<span class="id" title="var">n</span>:<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>) : <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a><br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;将本行替换成&nbsp;":=&nbsp;_你的_定义_&nbsp;."&nbsp;*)</span>. <span class="id" title="var">Admitted</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Example</span> <a name="test_factorial1"><span class="id" title="definition">test_factorial1</span></a>:          <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">(</span></a><a class="idref" href="Basics.html#factorial"><span class="id" title="axiom">factorial</span></a> 3<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> 6.<br/>
<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" title="var">Admitted</span>.<br/>
<span class="id" title="keyword">Example</span> <a name="test_factorial2"><span class="id" title="definition">test_factorial2</span></a>:          <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">(</span></a><a class="idref" href="Basics.html#factorial"><span class="id" title="axiom">factorial</span></a> 5<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">(</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Peano.html#mult"><span class="id" title="abbreviation">mult</span></a> 10 12<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">)</span></a>.<br/>
<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" title="var">Admitted</span>.<br/>
<font size=-2>&#9744;</font>
</div>

<div class="doc"> 
<div class="paragraph"> </div>

 我们可以通过引入加法、乘法和减法的<i>'记法（Notation）'</i>来让数字表达式更加易读。 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Notation</span> <a name="b3eea360671e1b32b18a26e15b3aace3"><span class="id" title="notation">&quot;</span></a>x + y" := (<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Peano.html#plus"><span class="id" title="abbreviation">plus</span></a> <span class="id" title="var">x</span> <span class="id" title="var">y</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 50, <span class="id" title="tactic">left</span> <span class="id" title="keyword">associativity</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <span class="id" title="var">nat_scope</span>.<br/>
<span class="id" title="keyword">Notation</span> <a name="9482aae3d3b06e249765c1225dbb8cbb"><span class="id" title="notation">&quot;</span></a>x - y" := (<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Peano.html#minus"><span class="id" title="abbreviation">minus</span></a> <span class="id" title="var">x</span> <span class="id" title="var">y</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 50, <span class="id" title="tactic">left</span> <span class="id" title="keyword">associativity</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <span class="id" title="var">nat_scope</span>.<br/>
<span class="id" title="keyword">Notation</span> <a name="697e4695610f677ae98a52af81f779d<sub>2</sub>"><span class="id" title="notation">&quot;</span></a>x * y" := (<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Peano.html#mult"><span class="id" title="abbreviation">mult</span></a> <span class="id" title="var">x</span> <span class="id" title="var">y</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 40, <span class="id" title="tactic">left</span> <span class="id" title="keyword">associativity</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <span class="id" title="var">nat_scope</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Check</span> (<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Peano.html#b3eea360671e1b32b18a26e15b3aace3"><span class="id" title="notation">(</span></a>0 <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Peano.html#b3eea360671e1b32b18a26e15b3aace3"><span class="id" title="notation">+</span></a> 1<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Peano.html#b3eea360671e1b32b18a26e15b3aace3"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Peano.html#b3eea360671e1b32b18a26e15b3aace3"><span class="id" title="notation">+</span></a> 1) : <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>.<br/>
</div>

<div class="doc">
（<span class="inlinecode"><span class="id" title="keyword">level</span></span>、<span class="inlinecode"><span class="id" title="keyword">associativity</span></span> 和 <span class="inlinecode"><span class="id" title="var">nat_scope</span></span> 标记控制着 Coq
    语法分析器如何处理上述记法。目前无需关注这些细节。有兴趣的读者可参阅本章末尾
    “关于记法的更多内容”一节。）

<div class="paragraph"> </div>

    注意，这些声明并不会改变我们之前的定义，而只是让 Coq 语法分析器接受用
    <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">y</span></span> 来代替 <span class="inlinecode"><span class="id" title="var">plus</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode"><span class="id" title="var">y</span></span>，并在 Coq 美化输出时反过来将 <span class="inlinecode"><span class="id" title="var">plus</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode"><span class="id" title="var">y</span></span>
    显示为 <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">y</span></span>。 
<div class="paragraph"> </div>

 Coq 几乎不包含任何内置定义，甚至连数值间的相等关系都是由用户来实现。
    <span class="inlinecode"><span class="id" title="var">eqb</span></span> 函数定义如下：该函数检验自然数 <span class="inlinecode"><span class="id" title="var">nat</span></span> 间是否满足相等关系 <span class="inlinecode"><span class="id" title="var">eq</span></span>，
    并以布尔值 <span class="inlinecode"><span class="id" title="var">bool</span></span> 表示。注意该定义使用嵌套匹配 <span class="inlinecode"><span class="id" title="keyword">match</span></span>
    （亦可仿照 <span class="inlinecode"><span class="id" title="var">minus</span></span> 使用并列匹配）。 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <a name="eqb"><span class="id" title="definition">eqb</span></a> (<span class="id" title="var">n</span> <span class="id" title="var">m</span> : <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>) : <a class="idref" href="Basics.html#bool"><span class="id" title="inductive">bool</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Basics.html#n"><span class="id" title="variable">n</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#O"><span class="id" title="constructor">O</span></a> ⇒ <span class="id" title="keyword">match</span> <a class="idref" href="Basics.html#m"><span class="id" title="variable">m</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#O"><span class="id" title="constructor">O</span></a> ⇒ <a class="idref" href="Basics.html#true"><span class="id" title="constructor">true</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> <span class="id" title="var">m'</span> ⇒ <a class="idref" href="Basics.html#false"><span class="id" title="constructor">false</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span><br/>
&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> <span class="id" title="var">n'</span> ⇒ <span class="id" title="keyword">match</span> <a class="idref" href="Basics.html#m"><span class="id" title="variable">m</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#O"><span class="id" title="constructor">O</span></a> ⇒ <a class="idref" href="Basics.html#false"><span class="id" title="constructor">false</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> <span class="id" title="var">m'</span> ⇒ <a class="idref" href="Basics.html#eqb"><span class="id" title="definition">eqb</span></a> <span class="id" title="var">n'</span> <span class="id" title="var">m'</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>
</div>

<div class="doc">
类似地，<span class="inlinecode"><span class="id" title="var">leb</span></span> 函数检验其第一个参数是否小于等于第二个参数，以布尔值表示。 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <a name="leb"><span class="id" title="definition">leb</span></a> (<span class="id" title="var">n</span> <span class="id" title="var">m</span> : <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>) : <a class="idref" href="Basics.html#bool"><span class="id" title="inductive">bool</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Basics.html#n"><span class="id" title="variable">n</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#O"><span class="id" title="constructor">O</span></a> ⇒ <a class="idref" href="Basics.html#true"><span class="id" title="constructor">true</span></a><br/>
&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> <span class="id" title="var">n'</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Basics.html#m"><span class="id" title="variable">m</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#O"><span class="id" title="constructor">O</span></a> ⇒ <a class="idref" href="Basics.html#false"><span class="id" title="constructor">false</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> <span class="id" title="var">m'</span> ⇒ <a class="idref" href="Basics.html#leb"><span class="id" title="definition">leb</span></a> <span class="id" title="var">n'</span> <span class="id" title="var">m'</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Example</span> <a name="test_leb1"><span class="id" title="definition">test_leb1</span></a>:                <a class="idref" href="Basics.html#leb"><span class="id" title="definition">leb</span></a> 2 2 <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="Basics.html#true"><span class="id" title="constructor">true</span></a>.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>
<span class="id" title="keyword">Example</span> <a name="test_leb2"><span class="id" title="definition">test_leb2</span></a>:                <a class="idref" href="Basics.html#leb"><span class="id" title="definition">leb</span></a> 2 4 <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="Basics.html#true"><span class="id" title="constructor">true</span></a>.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>
<span class="id" title="keyword">Example</span> <a name="test_leb3"><span class="id" title="definition">test_leb3</span></a>:                <a class="idref" href="Basics.html#leb"><span class="id" title="definition">leb</span></a> 4 2 <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="Basics.html#false"><span class="id" title="constructor">false</span></a>.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
我们之后会经常用到它们（特别是 <span class="inlinecode"><span class="id" title="var">eqb</span></span>），因此先定义好它们的中缀记法： 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Notation</span> <a name="97a8d8c92e88d1d68fb55a13a4fcfc6d"><span class="id" title="notation">&quot;</span></a>x =? y" := (<a class="idref" href="Basics.html#eqb"><span class="id" title="definition">eqb</span></a> <span class="id" title="var">x</span> <span class="id" title="var">y</span>) (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 70) : <span class="id" title="var">nat_scope</span>.<br/>
<span class="id" title="keyword">Notation</span> <a name="01f84f7b4db7ca25b5fbdf8f04a7bebc"><span class="id" title="notation">&quot;</span></a>x &lt;=? y" := (<a class="idref" href="Basics.html#leb"><span class="id" title="definition">leb</span></a> <span class="id" title="var">x</span> <span class="id" title="var">y</span>) (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 70) : <span class="id" title="var">nat_scope</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Example</span> <a name="test_leb3'"><span class="id" title="definition">test_leb3'</span></a>: <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">(</span></a>4 <a class="idref" href="Basics.html#01f84f7b4db7ca25b5fbdf8f04a7bebc"><span class="id" title="notation">&lt;=?</span></a> 2<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="Basics.html#false"><span class="id" title="constructor">false</span></a>.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<a name="lab33"></a><h4 class="section">练习：1 星, standard (ltb)</h4>
 <span class="inlinecode"><span class="id" title="var">ltb</span></span> 函数检验自然数间的小于关系，以布尔值表示。
    请利用前文定义的函数写出该定义，不要使用 <span class="inlinecode"><span class="id" title="keyword">Fixpoint</span></span> 构造新的递归。
    （只需前文中的一个函数即可实现该定义，不过也可两者皆用。） 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <a name="ltb"><span class="id" title="definition">ltb</span></a> (<span class="id" title="var">n</span> <span class="id" title="var">m</span> : <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>) : <a class="idref" href="Basics.html#bool"><span class="id" title="inductive">bool</span></a><br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;将本行替换成&nbsp;":=&nbsp;_你的_定义_&nbsp;."&nbsp;*)</span>. <span class="id" title="var">Admitted</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Notation</span> <a name="558f8b76d149cdb311ec341fe9014aa<sub>8</sub>"><span class="id" title="notation">&quot;</span></a>x &lt;? y" := (<a class="idref" href="Basics.html#ltb"><span class="id" title="axiom">ltb</span></a> <span class="id" title="var">x</span> <span class="id" title="var">y</span>) (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 70) : <span class="id" title="var">nat_scope</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Example</span> <a name="test_ltb1"><span class="id" title="definition">test_ltb1</span></a>:             <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">(</span></a><a class="idref" href="Basics.html#ltb"><span class="id" title="axiom">ltb</span></a> 2 2<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="Basics.html#false"><span class="id" title="constructor">false</span></a>.<br/>
<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" title="var">Admitted</span>.<br/>
<span class="id" title="keyword">Example</span> <a name="test_ltb2"><span class="id" title="definition">test_ltb2</span></a>:             <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">(</span></a><a class="idref" href="Basics.html#ltb"><span class="id" title="axiom">ltb</span></a> 2 4<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="Basics.html#true"><span class="id" title="constructor">true</span></a>.<br/>
<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" title="var">Admitted</span>.<br/>
<span class="id" title="keyword">Example</span> <a name="test_ltb3"><span class="id" title="definition">test_ltb3</span></a>:             <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">(</span></a><a class="idref" href="Basics.html#ltb"><span class="id" title="axiom">ltb</span></a> 4 2<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="Basics.html#false"><span class="id" title="constructor">false</span></a>.<br/>
<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" title="var">Admitted</span>.<br/>
<font size=-2>&#9744;</font>
</div>


<div class="doc">
<a name="lab34"></a><h1 class="section">基于化简的证明</h1>

<div class="paragraph"> </div>

 至此，我们已经定义了一些数据类型和函数。让我们把问题转到如何表述和证明
    它们行为的性质上来。其实我们已经开始这样做了：前几节中的每个 <span class="inlinecode"><span class="id" title="keyword">Example</span></span>
    都对几个函数在某些特定输入上的行为做出了准确的断言。这些断言的证明方法都一样：
    使用 <span class="inlinecode"><span class="id" title="tactic">simpl</span></span> 来化简等式两边，然后用 <span class="inlinecode"><span class="id" title="tactic">reflexivity</span></span> 来检查两边是否具有相同的值。

<div class="paragraph"> </div>

    这类“基于化简的证明”还可以用来证明更多有趣的性质。例如，对于“<span class="inlinecode">0</span>
    出现在左边时是加法 <span class="inlinecode">+</span> 的‘幺元’”这一事实，我们只需读一遍 <span class="inlinecode"><span class="id" title="var">plus</span></span> 的定义，
    即可通过观察“对于 <span class="inlinecode">0</span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">n</span></span>，无论 <span class="inlinecode"><span class="id" title="var">n</span></span> 的值为多少均可化简为 <span class="inlinecode"><span class="id" title="var">n</span></span>”而得到证明。 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="plus_O_n"><span class="id" title="lemma">plus_O_n</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span> : <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>, 0 <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Peano.html#b3eea360671e1b32b18a26e15b3aace3"><span class="id" title="notation">+</span></a> <a class="idref" href="Basics.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="Basics.html#n"><span class="id" title="variable">n</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span>. <span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
（或许你会注意到以上语句在你的 IDE 中和在浏览器渲染的 HTML
    中不大一样，我们用保留标识符“forall”来表示全称量词
    <span class="inlinecode"><span class="id" title="keyword">∀</span></span>。当 <span class="inlinecode">.<span class="id" title="var">v</span></span> 文件转换为 HTML 后，它会变成一个倒立的“A”。）

<div class="paragraph"> </div>

    现在是时候说一下 <span class="inlinecode"><span class="id" title="tactic">reflexivity</span></span> 了，它其实比我们想象的更为强大。
    在前面的例子中，其实并不需要调用 <span class="inlinecode"><span class="id" title="tactic">simpl</span></span> ，因为 <span class="inlinecode"><span class="id" title="tactic">reflexivity</span></span>
    在检查等式两边是否相等时会自动做一些化简；我们加上 <span class="inlinecode"><span class="id" title="tactic">simpl</span></span> 只是为了看到化简之后，
    证明结束之前的中间状态。下面是对同一定理更短的证明：
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="plus_O_n'"><span class="id" title="lemma">plus_O_n'</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span> : <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>, 0 <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Peano.html#b3eea360671e1b32b18a26e15b3aace3"><span class="id" title="notation">+</span></a> <a class="idref" href="Basics.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="Basics.html#n"><span class="id" title="variable">n</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
此外，<span class="inlinecode"><span class="id" title="tactic">reflexivity</span></span> 在某些方面做了比 <span class="inlinecode"><span class="id" title="tactic">simpl</span></span> <i>'更多'</i>的化简 ——
    比如它会尝试“展开”已定义的项，将它们替换为该定义右侧的值。
    了解这一点会很有帮助。产生这种差别的原因是，当自反性成立时，
    整个证明目标就完成了，我们不必再关心 <span class="inlinecode"><span class="id" title="tactic">reflexivity</span></span> 化简和展开了什么；
    而当我们必须去观察和理解新产生的证明目标时，我们并不希望盲目地展开定义，
    将证明目标留在混乱的声明中。这种情况下就要用到 <span class="inlinecode"><span class="id" title="tactic">simpl</span></span> 了。

<div class="paragraph"> </div>

    我们刚刚声明的定理形式及其证明与前面的例子基本相同，它们只有一点差别。

<div class="paragraph"> </div>

    首先，我们使用了关键字 <span class="inlinecode"><span class="id" title="keyword">Theorem</span></span> 而非 <span class="inlinecode"><span class="id" title="keyword">Example</span></span>。这种差别纯粹是风格问题；
    在 Coq 中，关键字 <span class="inlinecode"><span class="id" title="keyword">Example</span></span> 和 <span class="inlinecode"><span class="id" title="keyword">Theorem</span></span>（以及其它一些，包括 <span class="inlinecode"><span class="id" title="keyword">Lemma</span></span>、<span class="inlinecode"><span class="id" title="keyword">Fact</span></span>
    和 <span class="inlinecode"><span class="id" title="keyword">Remark</span></span>）都表示完全一样的东西。

<div class="paragraph"> </div>

    其次，我们增加了量词 <span class="inlinecode"><span class="id" title="keyword">∀</span></span> <span class="inlinecode"><span class="id" title="var">n</span>:<span class="id" title="var">nat</span></span>，因此我们的定理讨论了<i>'所有的'</i> 自然数 <span class="inlinecode"><span class="id" title="var">n</span></span>。
    在非形式化的证明中，为了证明这种形式的定理，我们通常会说“<i>'假设'</i>
    存在一个任意自然数 <span class="inlinecode"><span class="id" title="var">n</span></span>...”。而在形式化证明中，这是用 <span class="inlinecode"><span class="id" title="tactic">intros</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span>
    来实现的，它会将量词从证明目标转移到当前假设的<i>'上下文'</i>中。
    注意在 <span class="inlinecode"><span class="id" title="tactic">intros</span></span> 从句中，我们可以使用别的标识符来代替 <span class="inlinecode"><span class="id" title="var">n</span></span>
    （当然这可能会让阅读证明的人感到困惑）：

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="plus_O_n''"><span class="id" title="lemma">plus_O_n''</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span> : <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>, 0 <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Peano.html#b3eea360671e1b32b18a26e15b3aace3"><span class="id" title="notation">+</span></a> <a class="idref" href="Basics.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="Basics.html#n"><span class="id" title="variable">n</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">m</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
关键字 <span class="inlinecode"><span class="id" title="tactic">intros</span></span>、<span class="inlinecode"><span class="id" title="tactic">simpl</span></span> 和 <span class="inlinecode"><span class="id" title="tactic">reflexivity</span></span> 都是<i>'策略（Tactic）'</i>的例子。
    策略是一条可以用在 <span class="inlinecode"><span class="id" title="keyword">Proof</span></span>（证明）和 <span class="inlinecode"><span class="id" title="keyword">Qed</span></span>（证毕）之间的指令，它告诉 Coq
    如何来检验我们所下的一些断言的正确性。在本章剩余的部分及以后的课程中，
    我们会见到更多的策略。 
<div class="paragraph"> </div>

 其它类似的定理可通过相同的模式证明。 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="plus_1_l"><span class="id" title="lemma">plus_1_l</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span>:<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>, 1 <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Peano.html#b3eea360671e1b32b18a26e15b3aace3"><span class="id" title="notation">+</span></a> <a class="idref" href="Basics.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> <a class="idref" href="Basics.html#n"><span class="id" title="variable">n</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Theorem</span> <a name="mult_0_l"><span class="id" title="lemma">mult_0_l</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span>:<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>, 0 <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Peano.html#697e4695610f677ae98a52af81f779d<sub>2</sub>"><span class="id" title="notation">×</span></a> <a class="idref" href="Basics.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> 0.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
上述定理名称的后缀 <span class="inlinecode"><span class="id" title="var">_l</span></span> 读作“在左边”。 
<div class="paragraph"> </div>

 跟进这些证明的每个步骤，观察上下文及证明目标的变化是非常值得的。
    你可能要在 <span class="inlinecode"><span class="id" title="tactic">reflexivity</span></span> 前面加上 <span class="inlinecode"><span class="id" title="tactic">simpl</span></span> 调用，以便观察 Coq
    在检查它们的相等关系前进行的化简。 
</div>

<div class="doc">
<a name="lab35"></a><h1 class="section">基于改写的证明</h1>

<div class="paragraph"> </div>

 下面这个定理比我们之前见过的更加有趣： 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="plus_id_example"><span class="id" title="lemma">plus_id_example</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span>:<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Basics.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="Basics.html#m"><span class="id" title="variable">m</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Basics.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Peano.html#b3eea360671e1b32b18a26e15b3aace3"><span class="id" title="notation">+</span></a> <a class="idref" href="Basics.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="Basics.html#m"><span class="id" title="variable">m</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Peano.html#b3eea360671e1b32b18a26e15b3aace3"><span class="id" title="notation">+</span></a> <a class="idref" href="Basics.html#m"><span class="id" title="variable">m</span></a>.<br/>
</div>

<div class="doc">
该定理并未对自然数 <span class="inlinecode"><span class="id" title="var">n</span></span> 和 <span class="inlinecode"><span class="id" title="var">m</span></span> 所有可能的值做全称断言，而是讨论了仅当
    <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">m</span></span> 时这一更加特定情况。箭头符号读作“蕴含”。

<div class="paragraph"> </div>

    与此前相同，我们需要在能够假定存在自然数 <span class="inlinecode"><span class="id" title="var">n</span></span> 和 <span class="inlinecode"><span class="id" title="var">m</span></span> 的基础上进行推理。
    另外我们需要假定有前提 <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">m</span></span>。<span class="inlinecode"><span class="id" title="tactic">intros</span></span> 策略用来将这三条前提从证明目标
    移到当前上下文的假设中。

<div class="paragraph"> </div>

    由于 <span class="inlinecode"><span class="id" title="var">n</span></span> 和 <span class="inlinecode"><span class="id" title="var">m</span></span> 是任意自然数，我们无法用化简来证明此定理，
    不过可以通过观察来证明它。如果我们假设了 <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">m</span></span>，那么就可以将证明目标中的
    <span class="inlinecode"><span class="id" title="var">n</span></span> 替换成 <span class="inlinecode"><span class="id" title="var">m</span></span> 从而获得两边表达式相同的等式。用来告诉 Coq
    执行这种替换的策略叫做<i>'改写'</i> <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span>。 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;将两个量词移到上下文中：&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;将前提移到上下文中：&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;用前提改写目标：&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> → <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
证明的第一行将全称量词变量 <span class="inlinecode"><span class="id" title="var">n</span></span> 和 <span class="inlinecode"><span class="id" title="var">m</span></span> 移到上下文中。第二行将前提
    <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">m</span></span> 移到上下文中，并将其命名为 <span class="inlinecode"><span class="id" title="var">H</span></span>。第三行告诉 Coq
    改写当前目标（<span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">m</span></span>），把前提等式 <span class="inlinecode"><span class="id" title="var">H</span></span> 的左边替换成右边。

<div class="paragraph"> </div>

    (<span class="inlinecode"><span class="id" title="tactic">rewrite</span></span> 中的箭头与蕴含无关：它指示 Coq 从左往右地应用改写。
    若要从右往左改写，可以使用 <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span> <span class="inlinecode">&lt;-</span>。在上面的证明中试一试这种改变，
    看看 Coq 的反应有何不同。) 
<div class="paragraph"> </div>

<a name="lab36"></a><h4 class="section">练习：1 星, standard (plus_id_exercise)</h4>
 删除 "<span class="inlinecode"><span class="id" title="var">Admitted</span>.</span>" 并补完证明。 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="plus_id_exercise"><span class="id" title="lemma">plus_id_exercise</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> <span class="id" title="var">o</span> : <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Basics.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="Basics.html#m"><span class="id" title="variable">m</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="Basics.html#m"><span class="id" title="variable">m</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="Basics.html#o"><span class="id" title="variable">o</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="Basics.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Peano.html#b3eea360671e1b32b18a26e15b3aace3"><span class="id" title="notation">+</span></a> <a class="idref" href="Basics.html#m"><span class="id" title="variable">m</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="Basics.html#m"><span class="id" title="variable">m</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Peano.html#b3eea360671e1b32b18a26e15b3aace3"><span class="id" title="notation">+</span></a> <a class="idref" href="Basics.html#o"><span class="id" title="variable">o</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" title="var">Admitted</span>.<br/>
<font size=-2>&#9744;</font>
</div>

<div class="doc"> 
<div class="paragraph"> </div>

 <span class="inlinecode"><span class="id" title="var">Admitted</span></span> 指令告诉 Coq 我们想要跳过此定理的证明，而将其作为已知条件，
    这在开发较长的证明时很有用。在进行一些较大的命题论证时，我们能够声明一些附加的事实。
    既然我们认为这些事实对论证是有用的，就可以用 <span class="inlinecode"><span class="id" title="var">Admitted</span></span> 先不加怀疑地接受这些事实，
    然后继续思考大命题的论证。直到确认了该命题确实是有意义的，
    再回过头去证明刚才跳过的证明。但是要小心：每次你使用 <span class="inlinecode"><span class="id" title="var">Admitted</span></span>，
    你就为 Coq 这个完好、严密、形式化且封闭的世界开了一个毫无逻辑的后门。 
<div class="paragraph"> </div>

 <span class="inlinecode"><span class="id" title="keyword">Check</span></span> 命令也可用来检查以前声明的引理和定理。下面两个关于乘法引理来自于标准库。
    （在下一章中，我们会亲自证明它们。） 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Peano.html#mult_n_O"><span class="id" title="lemma">mult_n_O</span></a>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;forall&nbsp;n&nbsp;:&nbsp;nat,&nbsp;0&nbsp;=&nbsp;n&nbsp;*&nbsp;0&nbsp;*)</span><br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Check</span> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Peano.html#mult_n_Sm"><span class="id" title="lemma">mult_n_Sm</span></a>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;forall&nbsp;n&nbsp;m&nbsp;:&nbsp;nat,&nbsp;n&nbsp;*&nbsp;m&nbsp;+&nbsp;n&nbsp;=&nbsp;n&nbsp;*&nbsp;S&nbsp;m&nbsp;*)</span><br/>
</div>

<div class="doc">
除了上下文中现有的假设外，我们还可以通过 <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span> 策略来运用前期证明过的定理。
    如果前期证明的定理的语句中包含量词变量，如前例所示，Coq 会通过匹配当前的证明目标
    来尝试实例化（Instantiate）它们。 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="mult_n_0_m_0"><span class="id" title="lemma">mult_n_0_m_0</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Peano.html#b3eea360671e1b32b18a26e15b3aace3"><span class="id" title="notation">(</span></a><a class="idref" href="Basics.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Peano.html#697e4695610f677ae98a52af81f779d<sub>2</sub>"><span class="id" title="notation">×</span></a> 0<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Peano.html#b3eea360671e1b32b18a26e15b3aace3"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Peano.html#b3eea360671e1b32b18a26e15b3aace3"><span class="id" title="notation">+</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Peano.html#b3eea360671e1b32b18a26e15b3aace3"><span class="id" title="notation">(</span></a><a class="idref" href="Basics.html#m"><span class="id" title="variable">m</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Peano.html#697e4695610f677ae98a52af81f779d<sub>2</sub>"><span class="id" title="notation">×</span></a> 0<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Peano.html#b3eea360671e1b32b18a26e15b3aace3"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> 0.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> &lt;- <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Peano.html#mult_n_O"><span class="id" title="lemma">mult_n_O</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> &lt;- <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Peano.html#mult_n_O"><span class="id" title="lemma">mult_n_O</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<a name="lab37"></a><h4 class="section">练习：2 星, standard (mult_n_1)</h4>

</div>
<div class="code">
<span class="id" title="keyword">Theorem</span> <a name="mult_n_1"><span class="id" title="lemma">mult_n_1</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span> : <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Basics.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Peano.html#697e4695610f677ae98a52af81f779d<sub>2</sub>"><span class="id" title="notation">×</span></a> 1 <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="Basics.html#n"><span class="id" title="variable">n</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" title="var">Admitted</span>.<br/>
<font size=-2>&#9744;</font>
</div>


<div class="doc">
<a name="lab38"></a><h1 class="section">利用分类讨论来证明</h1>

<div class="paragraph"> </div>

 当然，并非一切都能通过简单的计算和改写来证明。通常，一些未知的，
    假定的值（如任意数值、布尔值、列表等等）会阻碍化简。
    例如，如果我们像以前一样使用 <span class="inlinecode"><span class="id" title="tactic">simpl</span></span> 策略尝试证明下面的事实，就会被卡住。
    （现在我们用 <span class="inlinecode"><span class="id" title="keyword">Abort</span></span> 指令来放弃证明。） 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="plus_1_neq_0_firsttry"><span class="id" title="lemma">plus_1_neq_0_firsttry</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span> : <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Basics.html#97a8d8c92e88d1d68fb55a13a4fcfc6d"><span class="id" title="notation">(</span></a><a class="idref" href="Basics.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Peano.html#b3eea360671e1b32b18a26e15b3aace3"><span class="id" title="notation">+</span></a> 1<a class="idref" href="Basics.html#97a8d8c92e88d1d68fb55a13a4fcfc6d"><span class="id" title="notation">)</span></a> <a class="idref" href="Basics.html#97a8d8c92e88d1d68fb55a13a4fcfc6d"><span class="id" title="notation">=?</span></a> 0 <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="Basics.html#false"><span class="id" title="constructor">false</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>. <span class="comment">(*&nbsp;无能为力!&nbsp;*)</span><br/>
<span class="id" title="keyword">Abort</span>.<br/>
</div>

<div class="doc">
原因在于：根据 <span class="inlinecode"><span class="id" title="var">eqb</span></span> 和 <span class="inlinecode">+</span> 的定义，其第一个参数先被 <span class="inlinecode"><span class="id" title="keyword">match</span></span> 匹配。
    但此处 <span class="inlinecode">+</span> 的第一个参数 <span class="inlinecode"><span class="id" title="var">n</span></span> 未知，而 <span class="inlinecode"><span class="id" title="var">eqb</span></span> 的第一个参数 <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode">1</span>
    是复合表达式，二者均无法化简。

<div class="paragraph"> </div>

    欲进行规约，则需分情况讨论 <span class="inlinecode"><span class="id" title="var">n</span></span> 的所有可能构造。如果 <span class="inlinecode"><span class="id" title="var">n</span></span> 为 <span class="inlinecode"><span class="id" title="var">O</span></span>，
    则可验算 <span class="inlinecode">(<span class="id" title="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode">1)</span> <span class="inlinecode">=?</span> <span class="inlinecode">0</span> 的结果确实为 <span class="inlinecode"><span class="id" title="var">false</span></span>；如果 <span class="inlinecode"><span class="id" title="var">n</span></span> 由 <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n'</span></span> 构造，
    那么即使我们不知道 <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode">1</span> 表示什么，但至少知道它的构造子为 <span class="inlinecode"><span class="id" title="var">S</span></span>，
    因而足以得出 <span class="inlinecode">(<span class="id" title="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode">1)</span> <span class="inlinecode">=?</span> <span class="inlinecode">0</span> 的结果为 <span class="inlinecode"><span class="id" title="var">false</span></span>。

<div class="paragraph"> </div>

    告诉 Coq 分别对 <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode">0</span> 和 <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n'</span></span> 这两种情况进行分析的策略，叫做 <span class="inlinecode"><span class="id" title="tactic">destruct</span></span>。 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="plus_1_neq_0"><span class="id" title="lemma">plus_1_neq_0</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span> : <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Basics.html#97a8d8c92e88d1d68fb55a13a4fcfc6d"><span class="id" title="notation">(</span></a><a class="idref" href="Basics.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Peano.html#b3eea360671e1b32b18a26e15b3aace3"><span class="id" title="notation">+</span></a> 1<a class="idref" href="Basics.html#97a8d8c92e88d1d68fb55a13a4fcfc6d"><span class="id" title="notation">)</span></a> <a class="idref" href="Basics.html#97a8d8c92e88d1d68fb55a13a4fcfc6d"><span class="id" title="notation">=?</span></a> 0 <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="Basics.html#false"><span class="id" title="constructor">false</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span>. <span class="id" title="tactic">destruct</span> <span class="id" title="var">n</span> <span class="id" title="keyword">as</span> [| <span class="id" title="var">n'</span>] <span class="id" title="var">eqn</span>:<span class="id" title="var">E</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" title="tactic">destruct</span></span> 策略会生成_两个_子目标，为了让 Coq 认可这个定理，
    我们必须接下来证明这两个子目标。

<div class="paragraph"> </div>

    <span class="inlinecode"><span class="id" title="keyword">as</span></span> <span class="inlinecode">[|</span> <span class="inlinecode"><span class="id" title="var">n'</span>]</span> 这种标注被称为 <i>'引入模式'</i>。它告诉 Coq 应当在每个子目标中
    使用什么样的变量名。总体而言，在方括号之间的是一个由 <span class="inlinecode">|</span> 隔开的
    <i>'列表的列表'</i>（译者注：list of lists）。在上面的例子中，第一个元素是
    一个空列表，因为 <span class="inlinecode"><span class="id" title="var">O</span></span> 构造子是一个空构造子（它没有任何参数）。
    第二个元素提供了包含单个变量名 <span class="inlinecode"><span class="id" title="var">n'</span></span> 的列表，因为 <span class="inlinecode"><span class="id" title="var">S</span></span> 是一个单构造子。

<div class="paragraph"> </div>

    在每个子目标中，Coq 会记录这个子目标中关于 <span class="inlinecode"><span class="id" title="var">n</span></span> 的假设，<span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode">0</span> 还是
    对于某个 n', <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n'</span></span>。而 <span class="inlinecode"><span class="id" title="var">eqn</span>:<span class="id" title="var">E</span></span> 记号则告知 Coq 以 <span class="inlinecode"><span class="id" title="var">E</span></span> 来命名这些
    假设。省略 <span class="inlinecode"><span class="id" title="var">eqn</span>:<span class="id" title="var">E</span></span> 会导致 Coq 省略这些假设。这种省略能够使得一些不需要
    显式用到这类假设的证明显得更加流畅。但在实践中最好还是保留他们，
    因为他们可以作为一种说明文档来在证明过程中指引你。

<div class="paragraph"> </div>

    第二行和第三行中的 <span class="inlinecode">-</span> 符号叫做<i>'标号'</i>，它标明了这两个生成的子目标所对应的证明部分。
    （译注：此处的“标号”应理解为一个项目列表中每个 <i>'条目'</i> 前的小标记，如 ‣ 或 •。）
    标号后面的证明脚本是一个子目标的完整证明。在本例中，每个子目标都简单地使用
    <span class="inlinecode"><span class="id" title="tactic">reflexivity</span></span> 完成了证明。通常，<span class="inlinecode"><span class="id" title="tactic">reflexivity</span></span> 本身会执行一些化简操作。
    例如，第二段证明将 <span class="inlinecode"><span class="id" title="tactic">at</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n'</span></span> <span class="inlinecode">+</span> <span class="inlinecode">1)</span> <span class="inlinecode">0</span> 化简成 <span class="inlinecode"><span class="id" title="var">false</span></span>，是通过先将
    <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n'</span></span> <span class="inlinecode">+</span> <span class="inlinecode">1)</span> 转写成 <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">n'</span></span> <span class="inlinecode">+</span> <span class="inlinecode">1)</span>，接着展开 <span class="inlinecode"><span class="id" title="var">beq_nat</span></span>，之后再化简 <span class="inlinecode"><span class="id" title="keyword">match</span></span> 完成的。

<div class="paragraph"> </div>

    用标号来区分情况是可选的：如果没有标号，Coq 只会简单地要求你依次证明每个子目标。
    尽管如此，使用标号仍然是一个好习惯。原因有二：首先，它能让证明的结构更加清晰易读。
    其次，标号能指示 Coq 在开始验证下一个目标前确认上一个子目标已完成，
    防止不同子目标的证明搅和在一起。这一点在大型开发中尤为重要，
    因为一些证明片段会导致很耗时的排错过程。

<div class="paragraph"> </div>

    在 Coq 中并没有既严格又便捷的规则来格式化证明 —— 尤其指应在哪里断行，
    以及证明中的段落应如何缩进以显示其嵌套结构。然而，无论格式的其它方面如何布局，
    只要在多个子目标生成的地方为每行开头标上标号，那么整个证明就会有很好的可读性。

<div class="paragraph"> </div>

    这里也有必要提一下关于每行代码长度的建议。Coq 的初学者有时爱走极端，
    要么一行只有一个策略语句，要么把整个证明都写在一行里。更好的风格则介于两者之间。
    一个合理的习惯是给自己设定一个每行 80 个字符的限制。更长的行会很难读，
    也不便于显示或打印。很多编辑器都能帮你做到。

<div class="paragraph"> </div>

    <span class="inlinecode"><span class="id" title="tactic">destruct</span></span> 策略可用于任何归纳定义的数据类型。比如，我们接下来会用它来证明
    布尔值的取反是对合（Involutive）的 —— 即，取反是自身的逆运算。 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="negb_involutive"><span class="id" title="lemma">negb_involutive</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">b</span> : <a class="idref" href="Basics.html#bool"><span class="id" title="inductive">bool</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Basics.html#negb"><span class="id" title="definition">negb</span></a> (<a class="idref" href="Basics.html#negb"><span class="id" title="definition">negb</span></a> <a class="idref" href="Basics.html#b"><span class="id" title="variable">b</span></a>) <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="Basics.html#b"><span class="id" title="variable">b</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">b</span>. <span class="id" title="tactic">destruct</span> <span class="id" title="var">b</span> <span class="id" title="var">eqn</span>:<span class="id" title="var">E</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
注意这里的 <span class="inlinecode"><span class="id" title="tactic">destruct</span></span> 没有 <span class="inlinecode"><span class="id" title="keyword">as</span></span> 子句，因为此处 <span class="inlinecode"><span class="id" title="tactic">destruct</span></span>
    生成的子分类均无需绑定任何变量，因此也就不必指定名字。
    实际上，我们也可以省略 <i>'任何'</i> <span class="inlinecode"><span class="id" title="tactic">destruct</span></span> 中的 <span class="inlinecode"><span class="id" title="keyword">as</span></span> 子句，
    Coq 会自动填上变量名。不过这通常是个坏习惯，因为如果任其自由决定的话，
    Coq 经常会选择一些容易令人混淆的名字。

<div class="paragraph"> </div>

    有时在一个子目标内调用 <span class="inlinecode"><span class="id" title="tactic">destruct</span></span>，产生出更多的证明义务（Proof Obligation）
    也非常有用。这时候，我们使用不同的标号来标记目标的不同“层级”，比如： 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="andb_commutative"><span class="id" title="lemma">andb_commutative</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">b</span> <span class="id" title="var">c</span>, <a class="idref" href="Basics.html#andb"><span class="id" title="definition">andb</span></a> <a class="idref" href="Basics.html#b"><span class="id" title="variable">b</span></a> <a class="idref" href="Basics.html#c"><span class="id" title="variable">c</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="Basics.html#andb"><span class="id" title="definition">andb</span></a> <a class="idref" href="Basics.html#c"><span class="id" title="variable">c</span></a> <a class="idref" href="Basics.html#b"><span class="id" title="variable">b</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">b</span> <span class="id" title="var">c</span>. <span class="id" title="tactic">destruct</span> <span class="id" title="var">b</span> <span class="id" title="var">eqn</span>:<span class="id" title="var">Eb</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">destruct</span> <span class="id" title="var">c</span> <span class="id" title="var">eqn</span>:<span class="id" title="var">Ec</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">destruct</span> <span class="id" title="var">c</span> <span class="id" title="var">eqn</span>:<span class="id" title="var">Ec</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
每一对 <span class="inlinecode"><span class="id" title="tactic">reflexivity</span></span> 调用和紧邻其上的 <span class="inlinecode"><span class="id" title="tactic">destruct</span></span>
    执行后生成的子目标对应。 
<div class="paragraph"> </div>

 除了 <span class="inlinecode">-</span> 和 <span class="inlinecode">+</span> 之外，还可以使用 <span class="inlinecode">×</span>（星号）或任何重复的标号符（如
    <span class="inlinecode">--</span> 或 <span class="inlinecode">***</span>）作为标号。我们也可以用花括号将每个子证明目标括起来： 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="andb_commutative'"><span class="id" title="lemma">andb_commutative'</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">b</span> <span class="id" title="var">c</span>, <a class="idref" href="Basics.html#andb"><span class="id" title="definition">andb</span></a> <a class="idref" href="Basics.html#b"><span class="id" title="variable">b</span></a> <a class="idref" href="Basics.html#c"><span class="id" title="variable">c</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="Basics.html#andb"><span class="id" title="definition">andb</span></a> <a class="idref" href="Basics.html#c"><span class="id" title="variable">c</span></a> <a class="idref" href="Basics.html#b"><span class="id" title="variable">b</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">b</span> <span class="id" title="var">c</span>. <span class="id" title="tactic">destruct</span> <span class="id" title="var">b</span> <span class="id" title="var">eqn</span>:<span class="id" title="var">Eb</span>.<br/>
&nbsp;&nbsp;{ <span class="id" title="tactic">destruct</span> <span class="id" title="var">c</span> <span class="id" title="var">eqn</span>:<span class="id" title="var">Ec</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id" title="tactic">reflexivity</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id" title="tactic">reflexivity</span>. } }<br/>
&nbsp;&nbsp;{ <span class="id" title="tactic">destruct</span> <span class="id" title="var">c</span> <span class="id" title="var">eqn</span>:<span class="id" title="var">Ec</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id" title="tactic">reflexivity</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id" title="tactic">reflexivity</span>. } }<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
由于花括号同时标识了证明的开始和结束，因此它们可以同时用于不同的子目标层级，
    如上例所示。此外，花括号还允许我们在一个证明中的多个层级下使用同一个标号。
    使用大括号、标号还是二者结合都纯粹是个人偏好问题。 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="andb3_exchange"><span class="id" title="lemma">andb3_exchange</span></a> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <span class="id" title="var">b</span> <span class="id" title="var">c</span> <span class="id" title="var">d</span>, <a class="idref" href="Basics.html#andb"><span class="id" title="definition">andb</span></a> (<a class="idref" href="Basics.html#andb"><span class="id" title="definition">andb</span></a> <a class="idref" href="Basics.html#b"><span class="id" title="variable">b</span></a> <a class="idref" href="Basics.html#c"><span class="id" title="variable">c</span></a>) <a class="idref" href="Basics.html#d"><span class="id" title="variable">d</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="Basics.html#andb"><span class="id" title="definition">andb</span></a> (<a class="idref" href="Basics.html#andb"><span class="id" title="definition">andb</span></a> <a class="idref" href="Basics.html#b"><span class="id" title="variable">b</span></a> <a class="idref" href="Basics.html#d"><span class="id" title="variable">d</span></a>) <a class="idref" href="Basics.html#c"><span class="id" title="variable">c</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">b</span> <span class="id" title="var">c</span> <span class="id" title="var">d</span>. <span class="id" title="tactic">destruct</span> <span class="id" title="var">b</span> <span class="id" title="var">eqn</span>:<span class="id" title="var">Eb</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">destruct</span> <span class="id" title="var">c</span> <span class="id" title="var">eqn</span>:<span class="id" title="var">Ec</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id" title="tactic">destruct</span> <span class="id" title="var">d</span> <span class="id" title="var">eqn</span>:<span class="id" title="var">Ed</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">reflexivity</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id" title="tactic">destruct</span> <span class="id" title="var">d</span> <span class="id" title="var">eqn</span>:<span class="id" title="var">Ed</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">reflexivity</span>. }<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">destruct</span> <span class="id" title="var">c</span> <span class="id" title="var">eqn</span>:<span class="id" title="var">Ec</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id" title="tactic">destruct</span> <span class="id" title="var">d</span> <span class="id" title="var">eqn</span>:<span class="id" title="var">Ed</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">reflexivity</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id" title="tactic">destruct</span> <span class="id" title="var">d</span> <span class="id" title="var">eqn</span>:<span class="id" title="var">Ed</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">reflexivity</span>. }<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
在本章结束之前，我们最后再说一种简便写法。或许你已经注意到了，
    很多证明在引入变量之后会立即对它进行情况分析：
<br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>. <span class="id" title="tactic">destruct</span> <span class="id" title="var">y</span> <span class="id" title="keyword">as</span> [|<span class="id" title="var">y</span>] <span class="id" title="var">eqn</span>:<span class="id" title="var">E</span>.
<div class="paragraph"> </div>

</span>    这种写法是如此的常见以至于 Coq 为它提供了一种简写：我们可以在引入
    一个变量的同时对他使用<i>'引入模式'</i>来进行分类讨论。例如，下面是一个对
    <span class="inlinecode"><span class="id" title="var">plus_1_neq_0</span></span> 的更简短证明。（这种简写的缺点也显而易见，
    我们无法再记录在每个子目标中所使用的假设，而之前我们可以通过
    <span class="inlinecode"><span class="id" title="var">eqn</span>:<span class="id" title="var">E</span></span> 将它们标注出来。） 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="plus_1_neq_0'"><span class="id" title="lemma">plus_1_neq_0'</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span> : <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Basics.html#97a8d8c92e88d1d68fb55a13a4fcfc6d"><span class="id" title="notation">(</span></a><a class="idref" href="Basics.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Peano.html#b3eea360671e1b32b18a26e15b3aace3"><span class="id" title="notation">+</span></a> 1<a class="idref" href="Basics.html#97a8d8c92e88d1d68fb55a13a4fcfc6d"><span class="id" title="notation">)</span></a> <a class="idref" href="Basics.html#97a8d8c92e88d1d68fb55a13a4fcfc6d"><span class="id" title="notation">=?</span></a> 0 <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="Basics.html#false"><span class="id" title="constructor">false</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> [|<span class="id" title="var">n</span>].<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
如果没有需要命名的构造子参数，我们只需写上 <span class="inlinecode">[]</span> 即可进行情况分析。 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="andb_commutative''"><span class="id" title="lemma">andb_commutative''</span></a> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <span class="id" title="var">b</span> <span class="id" title="var">c</span>, <a class="idref" href="Basics.html#andb"><span class="id" title="definition">andb</span></a> <a class="idref" href="Basics.html#b"><span class="id" title="variable">b</span></a> <a class="idref" href="Basics.html#c"><span class="id" title="variable">c</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="Basics.html#andb"><span class="id" title="definition">andb</span></a> <a class="idref" href="Basics.html#c"><span class="id" title="variable">c</span></a> <a class="idref" href="Basics.html#b"><span class="id" title="variable">b</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> [] [].<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<a name="lab39"></a><h4 class="section">练习：2 星, standard (andb_true_elim2)</h4>
 证明以下断言, 当使用 <span class="inlinecode"><span class="id" title="tactic">destruct</span></span> 时请用标号标出情况（以及子情况）。 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="andb_true_elim2"><span class="id" title="lemma">andb_true_elim2</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">b</span> <span class="id" title="var">c</span> : <a class="idref" href="Basics.html#bool"><span class="id" title="inductive">bool</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Basics.html#andb"><span class="id" title="definition">andb</span></a> <a class="idref" href="Basics.html#b"><span class="id" title="variable">b</span></a> <a class="idref" href="Basics.html#c"><span class="id" title="variable">c</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="Basics.html#true"><span class="id" title="constructor">true</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="Basics.html#c"><span class="id" title="variable">c</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="Basics.html#true"><span class="id" title="constructor">true</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" title="var">Admitted</span>.<br/>
<font size=-2>&#9744;</font>
</div>

<div class="doc"> 
<div class="paragraph"> </div>

<a name="lab40"></a><h4 class="section">练习：1 星, standard (zero_nbeq_plus_1)</h4>

</div>
<div class="code">
<span class="id" title="keyword">Theorem</span> <a name="zero_nbeq_plus_1"><span class="id" title="lemma">zero_nbeq_plus_1</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span> : <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>,<br/>
&nbsp;&nbsp;0 <a class="idref" href="Basics.html#97a8d8c92e88d1d68fb55a13a4fcfc6d"><span class="id" title="notation">=?</span></a> <a class="idref" href="Basics.html#97a8d8c92e88d1d68fb55a13a4fcfc6d"><span class="id" title="notation">(</span></a><a class="idref" href="Basics.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Peano.html#b3eea360671e1b32b18a26e15b3aace3"><span class="id" title="notation">+</span></a> 1<a class="idref" href="Basics.html#97a8d8c92e88d1d68fb55a13a4fcfc6d"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="Basics.html#false"><span class="id" title="constructor">false</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" title="var">Admitted</span>.<br/>
<font size=-2>&#9744;</font>
</div>


<div class="doc">
<a name="lab41"></a><h1 class="section">关于记法的更多内容 (可选)</h1>

<div class="paragraph"> </div>

 （通常，标为可选的部分对于跟进本书其它部分的学习来说不是必须的，
    除了那些也标记为可选的部分。在初次阅读时，你可以快速浏览这些部分，
    以便在将来遇到时能够想起来这里讲了些什么。）

<div class="paragraph"> </div>

    回忆一下中缀加法和乘法的记法定义：
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Notation</span> <a name="b3eea360671e1b32b18a26e15b3aace3"><span class="id" title="notation">&quot;</span></a>x + y" := (<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Peano.html#plus"><span class="id" title="abbreviation">plus</span></a> <span class="id" title="var">x</span> <span class="id" title="var">y</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 50, <span class="id" title="tactic">left</span> <span class="id" title="keyword">associativity</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <span class="id" title="var">nat_scope</span>.<br/>
<span class="id" title="keyword">Notation</span> <a name="697e4695610f677ae98a52af81f779d<sub>2</sub>"><span class="id" title="notation">&quot;</span></a>x * y" := (<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Peano.html#mult"><span class="id" title="abbreviation">mult</span></a> <span class="id" title="var">x</span> <span class="id" title="var">y</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 40, <span class="id" title="tactic">left</span> <span class="id" title="keyword">associativity</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <span class="id" title="var">nat_scope</span>.<br/>
</div>

<div class="doc">
对于 Coq 中的每个记法符号，我们可以指定它的 <i>'优先级'</i> 和 <i>'结合性'</i>。
    优先级 <span class="inlinecode"><span class="id" title="var">n</span></span> 用 <span class="inlinecode"><span class="id" title="tactic">at</span></span> <span class="inlinecode"><span class="id" title="keyword">level</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> 来表示，这样有助于 Coq 分析复合表达式。
    结合性的设置有助于消除表达式中相同符号出现多次时产生的歧义。比如，
    上面这组对 <span class="inlinecode">+</span> 和 <span class="inlinecode">×</span> 的参数定义的表达式 <span class="inlinecode">1+2*3*4</span> 是 <span class="inlinecode">(1+((2*3)*4))</span> 的
    简写。Coq 使用 0 到 100 的优先级等级，同时支持 <i>'左结合'</i>、<i>'右结合'</i>
    和 <i>'不结合'</i> 三种结合性。之后我们在别的章节会看到更多与此相关的例子，比如
    <a href="Lists.html"><span class="inlinecode"><span class="id" title="var">Lists</span></span></a> 一章。

<div class="paragraph"> </div>

    每个记法符号还与 <i>'记法范围（Notation Scope）'</i>相关。Coq 会尝试根据上下文来猜测
    你所指的范围，因此当你写出 <span class="inlinecode"><span class="id" title="var">S</span>(0*0)</span> 时，它猜测是 <span class="inlinecode"><span class="id" title="var">nat_scope</span></span>；而当你
    写出积（元组）类型 <span class="inlinecode"><span class="id" title="var">bool</span>×<span class="id" title="var">bool</span></span> 时，它猜测是 <span class="inlinecode"><span class="id" title="var">type_scope</span></span>。
    有时你可能必须百分号记法 <span class="inlinecode">(<span class="id" title="var">x</span>×<span class="id" title="var">y</span>)%<span class="id" title="var">nat</span></span> 来帮助 Coq 确定范围。
    另外，有时 Coq 打印的结果中也用 <span class="inlinecode">%<span class="id" title="var">nat</span></span> 来指示记法所在的范围。

<div class="paragraph"> </div>

    记法范围同样适用于数值记法（<span class="inlinecode">3</span>、<span class="inlinecode">4</span>、<span class="inlinecode">5</span>、<span class="inlinecode">42</span> 等等），因此你有时候会看到
    <span class="inlinecode">0%<span class="id" title="var">nat</span></span>，表示 <span class="inlinecode">0</span>（即我们在本章中使用的自然数零 <span class="inlinecode">0</span>），而 <span class="inlinecode">0%<span class="id" title="var">Z</span></span> 表示整数零
    （来自于标准库中的另一个部分）。

<div class="paragraph"> </div>

    专业提示：Coq 的符号机制不是特别强大，别期望太多。 
</div>

<div class="doc">
<a name="lab42"></a><h1 class="section">不动点 <span class="inlinecode"><span class="id" title="keyword">Fixpoint</span></span> 和结构化递归 (可选)</h1>

<div class="paragraph"> </div>

 以下是加法定义的一个副本： 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <a name="plus'"><span class="id" title="definition">plus'</span></a> (<span class="id" title="var">n</span> : <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>) (<span class="id" title="var">m</span> : <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>) : <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Basics.html#n"><span class="id" title="variable">n</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#O"><span class="id" title="constructor">O</span></a> ⇒ <a class="idref" href="Basics.html#m"><span class="id" title="variable">m</span></a><br/>
&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> <span class="id" title="var">n'</span> ⇒ <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> (<a class="idref" href="Basics.html#plus'"><span class="id" title="definition">plus'</span></a> <span class="id" title="var">n'</span> <a class="idref" href="Basics.html#m"><span class="id" title="variable">m</span></a>)<br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>
</div>

<div class="doc">
当 Coq 查看此定义时，它会注意到“<span class="inlinecode"><span class="id" title="var">plus'</span></span> 的第一个参数是递减的”。
    这意味着我们对参数 <span class="inlinecode"><span class="id" title="var">n</span></span> 执行了<i>'结构化递归'</i>。换言之，我们仅对严格递减的
    <span class="inlinecode"><span class="id" title="var">n</span></span> 值进行递归调用。这一点蕴含了“对 <span class="inlinecode"><span class="id" title="var">plus'</span></span> 的调用最终会停止”。
    Coq 要求每个 <span class="inlinecode"><span class="id" title="keyword">Fixpoint</span></span> 定义中的某些参数必须是“递减的”。

<div class="paragraph"> </div>

    这项要求是 Coq 的基本特性之一，它保证了 Coq 中定义的所有函数对于所有输入都会终止。
    然而，由于 Coq 的“递减分析”不是非常精致，
    因此有时必须用一点不同寻常的方式来编写函数。 
<div class="paragraph"> </div>

<a name="lab43"></a><h4 class="section">练习：2 星, standard, optional (decreasing)</h4>
 为了更好的理解这一点，请尝试写一个对于所有输入都_的确_终止的 <span class="inlinecode"><span class="id" title="keyword">Fixpoint</span></span>
    定义。但这个定义需要违背上述的限制，以此来让 Coq 拒绝。（如果您决定将这个可选
    练习作为作业，请确保您将您的解答注释掉以防止 Coq 拒绝执行整个文件。） 
</div>
<div class="code">

<br/>
<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span><br/>
<font size=-2>&#9744;</font>
</div>


<div class="doc">
<a name="lab44"></a><h1 class="section">更多练习</h1>

<div class="paragraph"> </div>

 Each SF chapter comes with a tester file (e.g.  <span class="inlinecode"><span class="id" title="var">BasicsTest.v</span></span>),
    containing scripts that check most of the exercises. You can run
    <span class="inlinecode"><span class="id" title="var">make</span></span> <span class="inlinecode"><span class="id" title="var">BasicsTest.vo</span></span> in a terminal and check its output to make
    sure you didn't miss anything. 
<div class="paragraph"> </div>

<a name="lab45"></a><h4 class="section">练习：1 星, standard (identity_fn_applied_twice)</h4>
 用你学过的策略证明以下关于布尔函数的定理。 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="identity_fn_applied_twice"><span class="id" title="lemma">identity_fn_applied_twice</span></a> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">∀</span> (<span class="id" title="var">f</span> : <a class="idref" href="Basics.html#bool"><span class="id" title="inductive">bool</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="Basics.html#bool"><span class="id" title="inductive">bool</span></a>),<br/>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">(</span></a><span class="id" title="keyword">∀</span> (<span class="id" title="var">x</span> : <a class="idref" href="Basics.html#bool"><span class="id" title="inductive">bool</span></a>), <a class="idref" href="Basics.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="Basics.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="Basics.html#x"><span class="id" title="variable">x</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<span class="id" title="keyword">∀</span> (<span class="id" title="var">b</span> : <a class="idref" href="Basics.html#bool"><span class="id" title="inductive">bool</span></a>), <a class="idref" href="Basics.html#f"><span class="id" title="variable">f</span></a> (<a class="idref" href="Basics.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="Basics.html#b"><span class="id" title="variable">b</span></a>) <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="Basics.html#b"><span class="id" title="variable">b</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" title="var">Admitted</span>.<br/>
<font size=-2>&#9744;</font>
</div>

<div class="doc"> 
<div class="paragraph"> </div>

<a name="lab46"></a><h4 class="section">练习：1 星, standard (negation_fn_applied_twice)</h4>
 现在声明并证明定理 <span class="inlinecode"><span class="id" title="var">negation_fn_applied_twice</span></span>，与上一个类似，
    但是第二个前提说明函数 <span class="inlinecode"><span class="id" title="var">f</span></span> 有 <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">negb</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> 的性质。 
</div>
<div class="code">

<br/>
<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span><br/><hr class='doublespaceincode'/>
<span class="comment">(*&nbsp;请勿修改下面这一行：&nbsp;*)</span><br/>
<span class="id" title="keyword">Definition</span> <a name="manual_grade_for_negation_fn_applied_twice"><span class="id" title="definition">manual_grade_for_negation_fn_applied_twice</span></a> : <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#option"><span class="id" title="inductive">option</span></a> (<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b<sub>5</sub>"><span class="id" title="notation">×</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Strings.String.html#string"><span class="id" title="inductive">string</span></a>) := <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#None"><span class="id" title="constructor">None</span></a>.<br/>
</div>

<div class="doc">
(The last definition is used by the autograder.)  <font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab47"></a><h4 class="section">练习：3 星, standard, optional (andb_eq_orb)</h4>
 请证明下列定理。（提示：此定理的证明可能会有点棘手，取决于你如何证明它。
    或许你需要先证明一到两个辅助引理。或者，你要记得未必要同时引入所有前提。） 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="andb_eq_orb"><span class="id" title="lemma">andb_eq_orb</span></a> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">∀</span> (<span class="id" title="var">b</span> <span class="id" title="var">c</span> : <a class="idref" href="Basics.html#bool"><span class="id" title="inductive">bool</span></a>),<br/>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">(</span></a><a class="idref" href="Basics.html#andb"><span class="id" title="definition">andb</span></a> <a class="idref" href="Basics.html#b"><span class="id" title="variable">b</span></a> <a class="idref" href="Basics.html#c"><span class="id" title="variable">c</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="Basics.html#orb"><span class="id" title="definition">orb</span></a> <a class="idref" href="Basics.html#b"><span class="id" title="variable">b</span></a> <a class="idref" href="Basics.html#c"><span class="id" title="variable">c</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Basics.html#b"><span class="id" title="variable">b</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="Basics.html#c"><span class="id" title="variable">c</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" title="var">Admitted</span>.<br/>
<font size=-2>&#9744;</font>
</div>

<div class="doc"> 
<div class="paragraph"> </div>

<a name="lab48"></a><h4 class="section">练习：3 星, standard (binary)</h4>

<div class="paragraph"> </div>

    我们可以将对于自然数的一进制表示推广成更高效的二进制数表达方式。
    对于一个二进制数，我们可以将它看成一个由 <span class="inlinecode"><span class="id" title="var">A</span></span> 构造子和 <span class="inlinecode"><span class="id" title="var">B</span></span> 构造子
    组成的序列（它们分别表示 0 和 1），而这个序列的结束符为 <span class="inlinecode"><span class="id" title="var">Z</span></span>。
    类似的，一个数的一进制表示可以看成一个由 <span class="inlinecode"><span class="id" title="var">S</span></span> 构造子组成，并由 <span class="inlinecode"><span class="id" title="var">O</span></span> 
    构造子结束的序列。 * )

<div class="paragraph"> </div>

    For example:
<br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">decimal</span>            <span class="id" title="var">binary</span>                           <span class="id" title="var">unary</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0                   <span class="id" title="var">Z</span>                              <span class="id" title="var">O</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1                 <span class="id" title="var">B</span> <span class="id" title="var">Z</span>                            <span class="id" title="var">S</span> <span class="id" title="var">O</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2              <span class="id" title="var">A</span> (<span class="id" title="var">B</span> <span class="id" title="var">Z</span>)                        <span class="id" title="var">S</span> (<span class="id" title="var">S</span> <span class="id" title="var">O</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3              <span class="id" title="var">B</span> (<span class="id" title="var">B</span> <span class="id" title="var">Z</span>)                     <span class="id" title="var">S</span> (<span class="id" title="var">S</span> (<span class="id" title="var">S</span> <span class="id" title="var">O</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4           <span class="id" title="var">A</span> (<span class="id" title="var">A</span> (<span class="id" title="var">B</span> <span class="id" title="var">Z</span>))                 <span class="id" title="var">S</span> (<span class="id" title="var">S</span> (<span class="id" title="var">S</span> (<span class="id" title="var">S</span> <span class="id" title="var">O</span>)))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5           <span class="id" title="var">B</span> (<span class="id" title="var">A</span> (<span class="id" title="var">B</span> <span class="id" title="var">Z</span>))              <span class="id" title="var">S</span> (<span class="id" title="var">S</span> (<span class="id" title="var">S</span> (<span class="id" title="var">S</span> (<span class="id" title="var">S</span> <span class="id" title="var">O</span>))))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6           <span class="id" title="var">A</span> (<span class="id" title="var">B</span> (<span class="id" title="var">B</span> <span class="id" title="var">Z</span>))           <span class="id" title="var">S</span> (<span class="id" title="var">S</span> (<span class="id" title="var">S</span> (<span class="id" title="var">S</span> (<span class="id" title="var">S</span> (<span class="id" title="var">S</span> <span class="id" title="var">O</span>)))))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7           <span class="id" title="var">B</span> (<span class="id" title="var">B</span> (<span class="id" title="var">B</span> <span class="id" title="var">Z</span>))        <span class="id" title="var">S</span> (<span class="id" title="var">S</span> (<span class="id" title="var">S</span> (<span class="id" title="var">S</span> (<span class="id" title="var">S</span> (<span class="id" title="var">S</span> (<span class="id" title="var">S</span> <span class="id" title="var">O</span>))))))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8        <span class="id" title="var">A</span> (<span class="id" title="var">A</span> (<span class="id" title="var">A</span> (<span class="id" title="var">B</span> <span class="id" title="var">Z</span>)))    <span class="id" title="var">S</span> (<span class="id" title="var">S</span> (<span class="id" title="var">S</span> (<span class="id" title="var">S</span> (<span class="id" title="var">S</span> (<span class="id" title="var">S</span> (<span class="id" title="var">S</span> (<span class="id" title="var">S</span> <span class="id" title="var">O</span>)))))))
<div class="paragraph"> </div>

</span>    注意到在上面的表示中，二进制数的低位被写在左边而高位写在右边。
   （与通常的二进制写法相反，这种写法可以让我们在证明中更好的操作他们。） 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <a name="bin"><span class="id" title="inductive">bin</span></a> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;| <a name="Z"><span class="id" title="constructor">Z</span></a><br/>
&nbsp;&nbsp;| <a name="A"><span class="id" title="constructor">A</span></a> (<span class="id" title="var">n</span> : <a class="idref" href="Basics.html#bin"><span class="id" title="inductive">bin</span></a>)<br/>
&nbsp;&nbsp;| <a name="B"><span class="id" title="constructor">B</span></a> (<span class="id" title="var">n</span> : <a class="idref" href="Basics.html#bin"><span class="id" title="inductive">bin</span></a>).<br/>
</div>

<div class="doc">
补全下面二进制自增函数 <span class="inlinecode"><span class="id" title="var">incr</span></span> 的定义。并且补全二进制数与一进制自然数转换的
    函数 <span class="inlinecode"><span class="id" title="var">bin_to_nat</span></span>。 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <a name="incr"><span class="id" title="definition">incr</span></a> (<span class="id" title="var">m</span>:<a class="idref" href="Basics.html#bin"><span class="id" title="inductive">bin</span></a>) : <a class="idref" href="Basics.html#bin"><span class="id" title="inductive">bin</span></a><br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;将本行替换成&nbsp;":=&nbsp;_你的_定义_&nbsp;."&nbsp;*)</span>. <span class="id" title="var">Admitted</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Fixpoint</span> <a name="bin_to_nat"><span class="id" title="definition">bin_to_nat</span></a> (<span class="id" title="var">m</span>:<a class="idref" href="Basics.html#bin"><span class="id" title="inductive">bin</span></a>) : <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a><br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;将本行替换成&nbsp;":=&nbsp;_你的_定义_&nbsp;."&nbsp;*)</span>. <span class="id" title="var">Admitted</span>.<br/>
</div>

<div class="doc">
下面这些针对单增函数和二进制转换函数的“单元测试”可以验算你的定义的正确性。
    当然，这些单元测试并不能确保你的定义在所有输入下都是正确的！我们在下一章的
    末尾会重新回到这个话题。 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Example</span> <a name="test_bin_incr1"><span class="id" title="definition">test_bin_incr1</span></a> : <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">(</span></a><a class="idref" href="Basics.html#incr"><span class="id" title="axiom">incr</span></a> (<a class="idref" href="Basics.html#B"><span class="id" title="constructor">B</span></a> <a class="idref" href="Basics.html#Z"><span class="id" title="constructor">Z</span></a>)<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="Basics.html#A"><span class="id" title="constructor">A</span></a> (<a class="idref" href="Basics.html#B"><span class="id" title="constructor">B</span></a> <a class="idref" href="Basics.html#Z"><span class="id" title="constructor">Z</span></a>).<br/>
<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" title="var">Admitted</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Example</span> <a name="test_bin_incr2"><span class="id" title="definition">test_bin_incr2</span></a> : <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">(</span></a><a class="idref" href="Basics.html#incr"><span class="id" title="axiom">incr</span></a> (<a class="idref" href="Basics.html#A"><span class="id" title="constructor">A</span></a> (<a class="idref" href="Basics.html#B"><span class="id" title="constructor">B</span></a> <a class="idref" href="Basics.html#Z"><span class="id" title="constructor">Z</span></a>))<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="Basics.html#B"><span class="id" title="constructor">B</span></a> (<a class="idref" href="Basics.html#B"><span class="id" title="constructor">B</span></a> <a class="idref" href="Basics.html#Z"><span class="id" title="constructor">Z</span></a>).<br/>
<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" title="var">Admitted</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Example</span> <a name="test_bin_incr3"><span class="id" title="definition">test_bin_incr3</span></a> : <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">(</span></a><a class="idref" href="Basics.html#incr"><span class="id" title="axiom">incr</span></a> (<a class="idref" href="Basics.html#B"><span class="id" title="constructor">B</span></a> (<a class="idref" href="Basics.html#B"><span class="id" title="constructor">B</span></a> <a class="idref" href="Basics.html#Z"><span class="id" title="constructor">Z</span></a>))<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="Basics.html#A"><span class="id" title="constructor">A</span></a> (<a class="idref" href="Basics.html#A"><span class="id" title="constructor">A</span></a> (<a class="idref" href="Basics.html#B"><span class="id" title="constructor">B</span></a> <a class="idref" href="Basics.html#Z"><span class="id" title="constructor">Z</span></a>)).<br/>
<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" title="var">Admitted</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Example</span> <a name="test_bin_incr4"><span class="id" title="definition">test_bin_incr4</span></a> : <a class="idref" href="Basics.html#bin_to_nat"><span class="id" title="axiom">bin_to_nat</span></a> (<a class="idref" href="Basics.html#A"><span class="id" title="constructor">A</span></a> (<a class="idref" href="Basics.html#B"><span class="id" title="constructor">B</span></a> <a class="idref" href="Basics.html#Z"><span class="id" title="constructor">Z</span></a>)) <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> 2.<br/>
<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" title="var">Admitted</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Example</span> <a name="test_bin_incr5"><span class="id" title="definition">test_bin_incr5</span></a> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Basics.html#bin_to_nat"><span class="id" title="axiom">bin_to_nat</span></a> (<a class="idref" href="Basics.html#incr"><span class="id" title="axiom">incr</span></a> (<a class="idref" href="Basics.html#B"><span class="id" title="constructor">B</span></a> <a class="idref" href="Basics.html#Z"><span class="id" title="constructor">Z</span></a>)) <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> 1 <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Peano.html#b3eea360671e1b32b18a26e15b3aace3"><span class="id" title="notation">+</span></a> <a class="idref" href="Basics.html#bin_to_nat"><span class="id" title="axiom">bin_to_nat</span></a> (<a class="idref" href="Basics.html#B"><span class="id" title="constructor">B</span></a> <a class="idref" href="Basics.html#Z"><span class="id" title="constructor">Z</span></a>).<br/>
<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" title="var">Admitted</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Example</span> <a name="test_bin_incr6"><span class="id" title="definition">test_bin_incr6</span></a> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Basics.html#bin_to_nat"><span class="id" title="axiom">bin_to_nat</span></a> (<a class="idref" href="Basics.html#incr"><span class="id" title="axiom">incr</span></a> (<a class="idref" href="Basics.html#incr"><span class="id" title="axiom">incr</span></a> (<a class="idref" href="Basics.html#B"><span class="id" title="constructor">B</span></a> <a class="idref" href="Basics.html#Z"><span class="id" title="constructor">Z</span></a>))) <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> 2 <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Peano.html#b3eea360671e1b32b18a26e15b3aace3"><span class="id" title="notation">+</span></a> <a class="idref" href="Basics.html#bin_to_nat"><span class="id" title="axiom">bin_to_nat</span></a> (<a class="idref" href="Basics.html#B"><span class="id" title="constructor">B</span></a> <a class="idref" href="Basics.html#Z"><span class="id" title="constructor">Z</span></a>).<br/>
<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" title="var">Admitted</span>.<br/>
<font size=-2>&#9744;</font>
</div>

<div class="code">

<br/>
<span class="comment">(*&nbsp;2022-03-14&nbsp;05:26:55&nbsp;(UTC+00)&nbsp;*)</span><br/>
</div>
</div>

<div id="footer">
<hr/><a href="coqindex.html">Index</a><hr/>This page has been generated by <a href="http://coq.inria.fr/">coqdoc</a>
</div>

</div>

</body>
</html>